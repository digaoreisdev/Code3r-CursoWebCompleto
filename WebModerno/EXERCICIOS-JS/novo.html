## Java Script

- **Iniciando com a Programa√ß√£o**
    - **[FUNDAMENTOS](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)**
        
        ** [Dicas de Atalhos](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        *[* Utilizando Operadores Destructuring](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        [** Operadores Aritim√©ticos](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Operadores L√≥gicos](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Operadores Tern√°rios](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Tratamento de Erros](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
    - [EXTRUTURAS DE CONTROLE](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Extrutura IF](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Extrutura If & Else](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Extrutura If & Else If & Else](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Extrutura Switch](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
    - [EXTRUTURAS DE REPETI√á√ÉO](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Extrutura While](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Extrutura DoWhile](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Extrutura For](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Extrutura For In](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
    - [USANDO O BREAK / CONTINUA√á√ÉO](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Break](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Continue](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
    - [FUN√á√ïES](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Parametros Padr√µes/Default](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [this (Recurso)](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [this e fun√ß√£o bind](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Fun√ß√µes Arrow](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Fun√ß√µes An√¥nimas](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Fun√ß√µes CallBack](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        *** [Fun√ß√£o callBack + Arrow Function](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Fun√ß√µes Construtoras](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Tipos de Declara√ß√µes de Fun√ß√µes](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Fun√ß√µes Factory](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Fun√ß√µes IIFE](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
    - [COMPARANDO STRING COM N√öMEROS](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    - [ORIENTA√á√ÉO AO OBJETO](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Maneiras de Se Criar Objetos em JS](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Entendendo Objetos ‚ÄúConstantes‚Äù](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Getter & Setters](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Fun√ß√µes Importantes dentro de Object](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Heran√ßa](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Evitando Modifica√ß√µes](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
    - [JSON VS OBJETO](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    - [CLASSES](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    - [ARRAY](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [**Fun√ß√µes Importantes dentro dos Arrays**](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        ** [Forma diferentes de Percorrer Arrays](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        *** [foreach( )](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        *** [map( )](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
        *** [filter( )](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        
    - [IMPERATIVOS VS DECLARATIVOS](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

- Dicas de Atalhos
    
    Para Comentar, ou tirar o coment√°rio de mais de uma senten√ßa ou um bloco inteiro de c√≥digos, basta selecionar todas as linhas que deseja comentar(descomentar) e tecle:
    
    ## Ctrl + /
    
    Para movimentar lateralmente uma ou mais linhas, basta selecionar o que deseja movimentar, e treclar
    
    ## Tab ‚áí Se o movimento desejado √© para direita
    
    ## Tab + Shift ‚áí Se o movimento desejado √© para esquerda
    
    Para duplicar uma ou mais linhas, basta selecionar o que deseja duplicar e teclar:
    
    ## Alt + Shift + Seta Pra Baixo
    
    Para Excluir uma linha inteira do c√≥digo, basta deixar o cursor no inicio da linha que deseja excluir, e teclar:
    
    ## Ctrl + X
    
    Para Formatar uma parte ou todo seu arquivo de forma a deixar com a configura√ß√£o document, selecione onde voc√™ quer formatar e tecle:
    
    ## Shift+ Alt + F
    

                                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# FUNDAMENTOS

### Utilizando Operadores Destructuring

*Operadores destructuring servem para ‚Äúdesesetruturar‚Äù objetos, fun√ß√µes ou classes, sem utilizar a nota√ß√£o ponto (.) para obter dados de dentro deles.*

*Este novo recurso foi inserido atrav√©s do ES2015.*

Vamos fazer exemplos para entender melhor esta ferramenta:

                                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## Operadores Destructuring para Objetos

- Primeiro operador destructuring que vamos usar, s√£o as chaves e utilizaremos eles para destruturar objetos:
    - Exemplos:
    
    ```jsx
    		const pessoa = {
    			nome: 'Ana',
    			idade: '5',
    			endereco: {
    				logradouro: 'Rua Abc',
    				numero: 1000	
    			}
    		}
    
    		const { nome, idade } = pessoa
    ```
    
    ***Nesta variavel logo a cima, eu estou indicando ao sistema com os operadores destructuring (chaves { }), para que ele me retorne os dados dos atributos nome e idade de dentro do objeto pessoa.***
    
    ** Desta forma, ao imprimir no console estes atributos, o sistema ir√° me retornar os dados ‚Äúconstantes‚Äù dentro destas propriedades:
    
    ```jsx
    			console.log(nome, idade)
    ```
    
    ## # O Retorno ser√° ‚áí Ana 5
    
    ** * Outra maneira de fazer, √© nomeando as variaveis que ir√£o receber os dados dos atributos que pertecem ao objeto solicitado.*
    
    ```jsx
    const { nome: n, idade: i } = pessoa
    console.log(n, i)
    ```
    
    ## # O Retorno ser√° o mesmo ‚áí Ana 5
    
    *** Neste outro exemplo a baixo, vamos tentar retornar dois valores de propriedades que n√£o existem no objeto. A primeira propriedade com o nome* **sobrenome** *n√£o ir√° receber nenhum dado como padr√£o (default); j√° a segunda variavel com o nome* **bemHumorada** *ir√° receber como valor padr√£o para ela* **true***.*
    
    ```jsx
    const { sobrenome, bemHumorada = true }
    console.log(sobrenome, bemHumorada}
    ```
    
    ## # O Retorno ser√° a primeira posi√ß√£o, sobrenome ‚áí‚Äúundefined‚Äù
    
    ## # E o Retorno da segunda posi√ß√£o, que √© bemHumorada, ir√° retornar ‚áí true
    
    *** E para acessar os atributos de dentro do objeto ‚Äúendere√ßo‚Äù que esta dentro do objeto ‚Äúpessoa‚Äù. N√≥s vamos criar uma constante com o operador destructuring chaves, e dentro dela iremos informar para o sistema retirar os dados dos atributos logradouro, n√∫mero e cep de dentro do objeto endere√ßo, que ir√° receber estes atributos do onjeto pessoa.*
    
    ```jsx
    const { endereco: { logradouro, numero, cep }} = pessoa
    console.log(logradouro, numero, cep)
    ```
    
    ## # Como dentro do objeto endere√ßo n√£o h√° a propriedade cep, o console.log( ) ir√° retornar no terminal os dados que constam dentro de logradouro e numero, e cep retornar√° ‚Äúundefined‚Äù.
    
    **Rua ABC 1000 undefined**
    
    ü§© **ATEN√á√ÉO!!!** Se por acaso voc√™ tentar destruturar, remover propriedades de dentro de um objeto que n√£o existe dentro de outro objeto, o sistema n√£o ir√° rodar o c√≥digo.
    
    ```jsx
    const { conta: { ag, num} } = pessoa
    console.log(ag, num)
    ```
    
    ## # Como o objeto *conta* n√£o existe dentro do objeto *pessoa*, o sistema n√£o ir√° rodar com este c√≥digo a cima.
    

## Operadores Destructuring para Arrays

- N√≥s podemos usar tamb√©m operadores destructuring para destruturar arrays. O operador utilizado para fazer isso s√£o os colchetes **[  ]:**
    - Exemplos:
    
    ** Para remover o dado de dentro de um array com o destructuring, basta usar o conchetes como segue a baixo.
    
    ```jsx
    const [ a ] = [ 10 ]
    console.log(a)
    ```
    
    ## # O Retorno ser√° ‚áí 10
    
    ** Podemos fazer esta detrutura√ß√£o com v√°rios elementos, inclusive podendo pular os elementros de dentro do array, buscando os dados somente daqueles que voc√™s desejam obter propriamente ditos.
    
    ```jsx
    const [ n1, n3, , n5, n6 = 0 ] = [ 10, 7, 9, 8 ]
    console.log(n1, n3, n5, n6)
    ```
    
    ## # Observando bem a express√£o a cima, n√≥s teremos como retorno:
    
    - O valor de n1 = 10; ‚áí Elemento 1 do array
    - O valor de n3 = 09; ‚áí Elemento 3 do array
    - O valor de n5 = undefined; ‚áí N√£o existe elemento 5 no array
    - O valor de n6 = 0; ‚áí ***Seria undefined tamb√©m, por√©m, como foi definido o valor zero (0) para o elemento 6 dentro do array, caso n√£o houve valor algum, ele retorna zero (0) no terminal.***
    
    ** Para destrututurar um array que seja um elemento de dentro de outro array, precisamos cuidadar a posi√ß√£o de cada colchete **[** na express√£o.
    
    Ou seja, na express√£o que vem logo a baixo, como array base para ser detruturado, temos um array maior, cujo seus elementos s√£o outros dois arrays:
    
    - O primeiro array tem o seu primeiro elemento sem valor algum, o segundo elemento √© um 8 e o seu terceiro elemento √© um 8;
        - [Java Script](https://www.notion.so/Java-Script-11b6356a798e43f7b242f5089c742520)
    - O segundo array tem tr√™s elementos, sendo eles, 9, 6, 8;
        - [9, 6, 8]]
    
    Elemento final ‚áí **[ [ , 8, 8], [9, 6, 8] ]**
    
    Na express√£o de logo a baixo, como resposta n√≥s vamos querer o segundo elemento do segundo array de dentro do array maior. Segue:
    
    ```jsx
    const [, [ , nota]] = [[ , 8, 8], [9, 6, 8]]
    console.log(nota)
    ```
    
    ## # Ou seja, o retorno no terminal ser√° a nota 6
    

## Operadores Destructuring para Objetos dentro de Fun√ß√µes

** Agora vamos usar operadores destructuring de dentro de fun√ß√µes. Vamos fazer logo a baixo uma fun√ß√£o randomica, ou seja, que ir√° criar n√∫meros aleat√≥rios entre um valor minimo e um valor m√°ximo pr√© definido por n√≥s. Segue:

```jsx
function rand({ min = 0, max = 1000 }) {
	const valor = Math.random() * (max - min) + min
	return Math.floor(valor)
}
```

Para retornar valores aleat√≥rios atrav√©s desta fun√ß√£o, temos v√°rias maneiras.

- Primeira delas, √© criar um objeto que ter√° um valor para m√°ximo e um valor para minimo e mandar o sistema executar a fun√ß√£o rand que ir√° exibir valores na tela tendo como base os valores criados neste objeto:
    
    ```jsx
    const obj = { max:50, min: 40 }
    console.log(rand(obj))
    ```
    

## # O retorno ser√£o n√∫meros aleat√≥rios entre **40** e **50**

- Outra forma de retornar os mesmos resultados ao executar a fun√ß√£o ***rand*** que criamos, √© simplificando a express√£o, solicitando a execu√ß√£o desta fun√ß√£o, dando a ela como par√¢metros, um objeto contendo dois elementos, um max = 50 e um min = 40:
    
    ```jsx
    console.log(rand({ max:50, min:40 }))
    ```
    
    ## # Desta forma teremos o mesmo retorno, ou seja, n√∫meros aleat√≥rios entre **40** e **50**
    
- Tamb√©m podemos obter retorno, solicitando apenas um par√¢metro para esta fun√ß√£o:
    
    ```jsx
    console.log(rand({ min: 955 }))
    ```
    
    ## # O que ir√° retornar com este c√≥digo a cima, s√£o n√∫meros aleat√≥rios entre o min que determinamos como par√¢metro da fun√ß√£o, e 1000, que √© o valor que dereminos como default na fun√ß√£o rand.
    
- Outra retorno que podemos ter, √© passar como par√¢metro para a fun√ß√£o, um objeto vazio:
    
    ```jsx
    console.log(rand({ }))
    ```
    
    ## # O retorno deste c√≥digo, ser√£o n√∫meros aleat√≥rios entre os dados default da fun√ß√£o rand, ou seja, n√∫meros entre **0** e **1000**.
    
- ü§© **ATEN√á√ÉO!!**
    - Se por acaso tentarmos executar a fun√ß√£o rand, sem dar parametros para ela, como n√≥s criamos uma fun√ß√£o com operadores destructuring, n√£o havendo parametros, ela tentar√° destruturar o vazio, e o c√≥digo ir√° parar.
        
        ```jsx
        console.log(rand()) // IR√Å DAR ERRO
        ```
        
        ***Observa√ß√£o!!*** Uma das formas de deixar o usu√°rio n√£o fornecer parametros para a fun√ß√£o, visando que o c√≥digo n√£o trave, √© atribuimos como valor default (padr√£o) para a fun√ß√£o um objto vazio. Por√©m, ele n√£o ir√° gerar valor algum. Ou seja, a fun√ß√£o ficaria assim:
        
        ```jsx
        function rand({ min = 0, max = 1000 } = { }) {
        	const valor = Math.randon() * (max - min) + min
        	return Math.floor(valor)
        }
        ```
        
        ```jsx
        // console.log(rand()) - Nesta caso tamb√©m gera problema por estar vazio
        ```
        

### Utilizando Operadores Aritim√©ticos

*Operadores aritm√©ticos s√£o operadores de atribui√ß√£o. Operadores simples e de utiliza√ß√£o comum em todos os sistemas.*

- Seguem Algumas formas de operadores Aritim√©ticos:
    - **OPERADOR POLSTFIX**
        - operador **‚Äúd‚Äù** c/ ****operando **++**
            - **d++ ‚áí Este operando chama-se POLSTFIX.** Ou seja, o operando vem ***depois*** do operador;
    - **OPERADOR SULFIX**
        - operando **++** c/ ****operador **‚Äùd‚Äù**
            - **++d ‚áí Este operando chama-se PREFIX.** Ou seja, o operando vem ***antes*** do operador;
    - **OPERADOR INFIX**
        - operador **‚Äúd‚Äù** c/ ****operando **+** operador **‚Äúe‚Äù**
            - **d + e ‚áí Este operando chama-se INFIX.** Ou seja, neste caso vem primeiro um operador, depois vem um operando e depois mais um operador;
    - **OPERADORES ARITIM√âTICOS BIN√ÅRIOS**
        
        S√£o operadores que utilizam um operador com um operando mais um operador.
        
        ```jsx
        const [ a, b, c, d ] = [ 3, 5, 1, 15 ]
        
        const soma = a + b + c + d
        const subtra√ß√£o = d - b
        const multiplicacao = a * b
        const divisao = d / a
        const modulo = a % 2
        ```
        
        ...Opera√ß√£o modulo, que √© a opera√ß√£o que pega o valor informado, divide por dois, e o resto da divis√£o √© que ser√° o valor informado para a variavel *modulo*
        
        ```jsx
        const modulo = a(3) % 2
        modulo = 1
        ```
        
        ```jsx
        const resultados = [soma, subtracao, multiplicacao, divisao, modulo]
        
        console.log(resultados)
        ```
        
        * Com estes informa√ß√µes a sima, n√≥s teremos como respostas:
        
        [ 24 10 15 5 1 ]
        
    - **OPERADORES ARITIM√âTICOS BIN√ÅRIOS RELACIONAIS**
        
        Operadores bin√°rios relacionais s√£o identificados em java script pelo resultado da opera√ß√£o. Isso porque, em JS, todas as vezes que usamos operadores relacionais, o resultado sempre ser√° **TRUE** (Verdadeiro) ou **FALSE** (Fal√ßo)
        
        Ex.: ***3*** √© maior do que ***2*** ? Resposta s√≥ pode ser **SIM** ou **N√ÉO**
        
        Outra particularidade destes operadores, √© a de que voc√™ pode fazer duas compara√ß√µes:
        
        - Comparar se os valores s√£o iguais, mesmo que os tipos de **valores** sejam de ‚Äútipagem‚Äù diferentes. E isso √© representando pelo operando **==**
        - Ou ent√£o, comparar al√©m dos **valores,** tamb√©m se as **tipagens** desses valores s√£o **estritamente** iguais. Neste caso representados pelo operando **===**
        
        ```jsx
        console.log('01) ', '1' == 1)
        console.log('02) ', '1' === 1)
        ```
        
        Neste console.log( ) a cima vamos ter dois resultados diferentes. Pois no primeiro exercicio o resultado √© **true,** pois a compara√ß√£o neste caso aqui, √© se a ***string*** 1 √© igual ao ***number*** 1. E neste caso √© SIM.
        
        J√° no segundo exerc√≠cio, a resposta ser√° **false**. Isso porque esta compara√ß√£o est√° questionando se a ***string*** 1, √© **exatamente** igual ao ***number*** 1, ou seja, se tanto os *valores*, quanto as *tipagens* destes valores s√£o exatamente iguais; o que no caso √© N√ÉO.
        
        ```jsx
        console.log('03) ', '3' != 3)
        ```
        
        Nesta compara√ß√£o estamos perguntando se 3 string, √© diferente de 3 number. Resposta **false**, porque os valores s√£o iguais.
        
        ```jsx
        console.log('03) ', '3' !== 3)
        ```
        
        Outra compara√ß√£o, e nesta o resultado √© false tamb√©m, porque a pergunta √© se valores e tipagens s√£o iguais, e n√£o s√£o. Uma √© *string* e outra √© *number*
        
        ```jsx
        console.log('01) ', '1' == 1)
        console.log('02) ', '1' === 1)
        
        console.log('03) ', '3' != 1)
        console.log('04) ', '3' !== 3)
        
        console.log('05) ', 3 < 2)
        console.log('06) ', 3 > 2)
        console.log('07) ', 3 <= 2)
        console.log('08) ', 3 >= 2)
        
        const d1 = new Date(0)
        const d2 = new Date(0)
        
        console.log('09) ', d1 === d2)
        console.log('10) ', d1 == d2)
        console.log('11) ', d1.getTime() === d2.getTime())
        
        console.log('12) ', undefined == null)
        console.log('13) ', undefined === null)
        ```
        
    - **OPERADORES ARITIM√âTICOS UN√ÅRIOS**
        
        S√£o operadores que utilizam apenas um operando mais um operador. Ou seja, o operador s√≥ poder√° ser PREFIX ou POLSTFIX. Exemplo:
        
        ```jsx
        const a = 3
        
        console.log(-a)
        ```
        
        * Nesta express√£o a cima, estamos dizendo para o sistema que o operador a recebe o valor 3, e depois ele √© impresso na tela com o sinal invertido. (-)3
        
        ```jsx
        const a = -3
        console.log(-a)
        ```
        
        *  J√° neste express√£o a cima, estamos dizendo para o sistema que ele deve inverter o operador de negativo para positivo. Ou seja, ser√° impresso na tela com o sinal invertido. (+)3
        
        ```jsx
        let num1 = 1
        let num2 = 2
        
        num1++
        console.log(num1)
        ```
        
        * Este operador un√°rio apenas acrescenta na variavel mais um.
        
        ```jsx
        let num1 = 1
        let num2 = 2
        
        --num1
        console.log(num1)
        ```
        
        * Operador que ir√° subtratir 1 unidade da variavel
        
        ü§© **ATEN√á√ÉO!!!**
        
        Teste l√≥gico para fazer:
        
        ```jsx
        console.log( ++num1 === num2-- )
        ```
        
        O retorno do c√≥digo a cima ser√° **false** ou **true**?
        
        A resposta √© **true** ‚áí Isso porque, em todas as linguagens de programa√ß√£o, os operadores, assim como na matem√°tica pura, tem uma ordem de execu√ß√£o. Neste c√≥digo digitado a cima, a ordem para rodar o programa √©:
        
        1. Sempre que houver uma operando PRE FIXADO, exemplo (++1, - - 1...), esta opera√ß√£o ser√° executado primeiro;
        2. Sempre que houver uma compara√ß√£o, primeiro sistema ir√° rodar o lado esquerdo da compara√ß√£o, e depois o lado direito. Exemplo: ( Esquerda(A) compara === com Direita(B)). Esta opera√ß√£o vai executar primeiro tudo o que estiver em A, para depois executar tudo o que estiver em B
        3. Quando na express√£o, houver um operando POLSTFIX, exemplo: (num++, num- -), ele ser√° executado por √∫ltimo.
    
- **ATEN√á√ÉO!!!** O n√∫mero zero(0) como refer√™ncia na formata√ß√£o de data
    
    O n√∫mero zero(0) como refer√™ncia na formata√ß√£o de data Date(0), corresponde a uma data de refer√™ncia no JS, que √© 01/01/1970, podendo variar um pouco por causa do fuso-hor√°rio.
    
    ```jsx
    const d1 = new Date(0)
    const d2 = new Date(0)
    
    console.log('09) , d1 === d2)
    console.log('10) , d1 == d2)
    console.log('11) , d1.getTime() === d2.getTime())
    console.log('12) ', undefined == null)
    console.log('13) ', undefined === null)
    ```
    
    false
    
    false
    
    true
    
    true
    
    false
    

### Utilizando Operadores L√≥gicos

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

Operadores l√≥gicos servem para executar um processo, caso a condi√ß√£o solicitada pelo sistema for verdadeira. Analisando friamente, eles oper√£o da seguinte maneira:

*** Utilizaremos V para verdadeiro - F para falso

```jsx
v E v = v
v E f = f
v E QUALQUER COISA = f

v OU QUALQUER COISA = v
f OU v = v
f OU f = f

v XOR v = f
v XOR f = v
f XOR v = v
f XOR f = f
// No OU exclusivo, os dois operandos precisam ser verdadeiros para retornar verdadeiro

!v => f
!f => v
/* A esclama√ß√£o logo a cima trata-se de uma nega√ß√£o l√≥gica. Nela o verdadeiro vira falso
 e o falso vir√° verdadeiro */
```

- **ü§© ATEN√á√ÉO! XOR** √© a sigla utilizada para o **OU EXCLUSIVO**
    
    
    ##  Por√©m, no JS n√£o existe o operador OU EXCLUSIVO para trablalhar com dados boleanos. Ent√£o utilizamos de artificios tecnol√≥gicos (gambiarra) para executa-lo.
    
    ```jsx
    const comprarTv32 = !!(trabalho1 ^ trabalho2) //bitwise xor
    ```
    
    Duas exclama√ß√µes antes do objeto √© um operando de nega√ß√£o l√≥gica que converte algo para bolean, e ent√£o utilizamos o OU bit a bit (bitwise) **^**
    
    ## Outra maneira de simular a utiliza√ß√£o do OU EXCLUSIVO, √© da forma que utilizamos logo a baixo. Ou seja, se falso √© diferente de verdadeiro... o resultado ser√° verdadeiro. Segue c√≥digo:
    
    ```jsx
    const comprarTv32 = trabalho1 != trabalho2
    ```
    

### Representa√ß√£o do E no c√≥digo JS === &&

### Representa√ß√£o do OU no c√≥digo JS === **||**

### **Trabalhando com operandos Condicionais:**

**CONDI√á√ÉO E ‚áí** Esta condi√ß√£o serve para que o c√≥digo seja executado, somente se todas as condi√ß√µes forem verdadeiras. Exemplo:

```jsx
SE numero1 = 1 e numero2 = 2 | retorne VERDADEIRO
```

Com est√° condicional a cima, o sistema somente ir√° responder verdadeiro se ambas as condi√ß√µes forem verdade.

**CONDI√á√ÉO OU ‚áí** Esta condi√ß√£o serve para que o c√≥digo seja executado, caso uma das condi√ß√µes seja atendida pelo c√≥digo. Exemplo:

```jsx
SE numero1 = 1 ou numero2 = 2 | retorne VERDADEIRO
```

Com est√° condicional a cima, o sistema ir√° responder se pelo menos uma das informa√ß√µes forem verdadeiras.

## Como exemplo, vamos criar uma fun√ß√£o com todas as condi√ß√µes mencionadas, afim de verificar quais ser√£o os devidos resultados:

```jsx
function compras(trabalho1, trabalho2) {
  const comprarSorvete = trabalho1 || trabalho2
  const comprarTv50 = trabalho1 && trabalho2
  //const comprarTv32 = !!(trabalho1 ^ trabalho2) //bitwise xor
  const comprarTv32 = trabalho1 != trabalho2
  const manterSaudavel = !comprarSorvete // operador unario

  return { comprarSorvete, comprarTv50, comprarTv32, manterSaudavel }

```

- 01. Exemplo:
    
    ```jsx
    console.log(compras(true, true))
    ```
    
    * Como neste console.log( ) informamos como parametro que os dois trabalhos aconteceram (s√£o verdadeiros) os resultados para nossas variaveis s√£o:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/62fde116-f997-4e1b-8668-12ac58672614/Untitled.png)
    
- 02. Exemplo:
    
    ```jsx
    console.log(compras(true, false))
    ```
    
    * Respostas:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/337a516a-edf3-4e54-9f66-9bf382f56924/Untitled.png)
    
- 03. Exemplo:
    
    ```jsx
    console.log(compras(false, true))
    ```
    
    * Respostas:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a35b2015-c4bd-47d2-9ef6-a087a6895c87/Untitled.png)
    
- 04. Exemplo:
    
    ```jsx
    console.log(compras(false, false))
    ```
    
    * Respostas:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4e20acc5-ab18-41a2-9a87-41a02f8a5fa5/Untitled.png)
    

### Utilizando Operadores Tern√°rios

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

Por obviedade, os operadores tern√°rios s√£o aqueles que possuem 3 operandos. Sendo assim, vamos direto ao exemplo:

* Vamos criar uma fun√ß√£o arow que ser√° atribuidade a uma variavel.

- 1¬™ Operando ‚áí uma opera√ß√£o relacional que ter√° como resultado, **true** ou **false** = **nota =>7**
- 2¬™ Operando ‚áí o que o sistema irar fazer se for true = **?** **‚ÄòAprovado‚Äô**

- 3¬™ Operando ‚áí o que o sistema irar fazer se for false = **:** **‚ÄòReprovado‚Äô**

```jsx
const resultado = nota => 7 ? 'Aprovado' : 'Reprovado'
console.log(resultado(7.1))
console.log(resultado(6.7))
```

Resultado:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/568fdc5b-b4cb-4381-afb9-fd6c7a10cb21/Untitled.png)

                                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# TRATAMENTO DE ERROS

O uso do tratamento de erros, serve para resolver possiveis erros que possam acontecer em nossos c√≥digos.

Vamos criar uma fun√ß√£o, e fazer o devido tratamento de erro com as propriedades:

- Try
- Catch
- Trhrow

```jsx
function imprimirNomeGritado(obj) {
	console.log(obj.name.toUpperCase() + '!!!'
}

const obj = { nome: 'Roberto' }
imprimirNomeGritado(obj)
```

Ao executar a fun√ß√£o imprimirNomeGritado vai dar um erro, pois o sistema n√£o ir√° conseguir usar o toUpperCase para um parametro nome, j√° que ele n√£o existe. Na verdade o √∫nico parametro que temos nesta fun√ß√£o recebeu, foi declarado como name.

Logo, para tratar estes erros, n√≥s faremos desta forma:

```jsx
function tratarErroElancar(erro) {
	throw new Error('...')
}

function imprimirNomeGritado(obj) {
	try {
		console.log(obj.name.toUpperCase() + '!!!')
	}
  catch (e) {
		tratarErroElancar(e)
	}
}

const obj = { nome: 'Rodrigo'}
imprimirNomeGritado(obj)
```

* Literalmente fazemos assim. No bloco T**ry {   }** colocamos nosso bloco de c√≥digos a serem executados.

* No bloco **Catch {   }** iremos colocar o que o programa ir√° fazer, caso ocorra algum tipo de erro no bloco try.

* E a propriedade **throw**, servir√° para lan√ßar o erro para o usu√°rio.

Ao executar agora a fun√ß√£o a cima, ele ir√° continuar a dar erro, por√©m ir√° retornar a mensagem: ***‚Äúthrow new ERROR(‚Äù...‚Äù)‚Äù***, exatamente como tratamos.

Para enriquecer ainda mais nosso conte√∫do, podemos retornar atrav√©s do throw, diversos tipos de informa√ß√µes para o tratamento do erro, s√£o elas:

```jsx
throw 10 //Retornar um number
throw true //Retornar um boelano
throw 'mensagem' //Retornar uma string
throw {
	nome: erro.name,
	msg: erro.message,
	date: New Date
} //Retornar um objeto
```

Ainda dentro do tratamento de erros, temos tamb√©m o bloco finally. Ele √© um bloco que se for mencionado no c√≥digo, ele ir√° ser executado sempre, dando erro ou n√£o em nosso c√≥digo:

```jsx
function tratarErroElancar(erro) {
	throw new Error('...')
}

function imprimirNomeGritado(obj) {
	try {
		console.log(obj.name.toUpperCase() + '!!!')
	}
  catch (e) {
		tratarErroElancar(e)
	} finally {
		console.log('final')
	}
}

const obj = { nome: 'Rodrigo'}
imprimirNomeGritado(obj)
```

                                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# EXTRUTURAS DE CONTROLE

## Extrutura If

Exemplo 01:

```jsx
function soBoaNoticia(nota) {
  if(nota >= 7) {
    console.log('Aprovado com ' + nota)
  }
}

soBoaNoticia(8.1)
soBoaNoticia(6.1)

function seForVerdadeEuFalo(valor) {
  if(valor) {
    console.log('√â verdade... ' + valor)
  }
}

seForVerdadeEuFalo()
seForVerdadeEuFalo(null)
seForVerdadeEuFalo(undefined)
seForVerdadeEuFalo(NaN)
seForVerdadeEuFalo('')
seForVerdadeEuFalo(0)
seForVerdadeEuFalo(-1)
seForVerdadeEuFalo(' ')
seForVerdadeEuFalo('?')
seForVerdadeEuFalo([])
seForVerdadeEuFalo([1, 2])
seForVerdadeEuFalo({})
```

Resultado:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/288b34d3-f230-454f-ad24-60603768d343/Untitled.png)

Exemplo 02:

Neste exemplo vou mostrar que a extrutura if quando tem apenas um bloco, n√£o presen√ßa das Chaves { } para entender a √∫nica senten√ßa.

```jsx
function teste1(num) {
  if(num > 7)
    console.log(num)
    console.log('Final')
}

teste1(6)
teste1(8)
```

Por√©m, precisa ficar atento neste exemplo, e reparar que a extrutura IF sem as chaves, vai considerar apenas 1 senten√ßa em seu c√≥digo. Por isso, o ideal √© sempre utilizar as chaves { } como padr√£o em seu c√≥digo.

- **Aten√ß√£o!!! N√£o usar ponto e virgula nas extruturas de controle**
    
    ```jsx
    function teste2(num) {
      if(num > 7); { // Cuidadado com o ponto e virgula;, n√£o usar com as extruturas de controle
        console.log(num)
      }
    }
    
    teste2(6)
    teste2(8)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a3e8fcf0-56ae-434f-98a7-6f8b82f931a5/Untitled.png)
    

## Extrutura If & Else

- Exemplos:
    
    Exemplo 01
    
    ```jsx
    const imprimirResultado = function(nota) {
      if(nota >= 7) {
        console.log('Aprovado!')
      } else [
        console.log('Reprovado!')
      ]
    }
    
    imprimirResultado(10)
    imprimirResultado(5.9)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a30fd0e1-8e44-4ae7-88eb-02b0ba60e8e1/Untitled.png)
    
    Exemplo 02
    
    Temos de cuidar o fato de o java script ser fracamente tipado. Pois voc√™ pode at√© informar uma string no lugar da nota, o sistema n√£o ir√° dar erro...
    
    ```jsx
    const imprimirResultado = function(nota) {
      if(nota >= 7) {
        console.log('Aprovado!')
      } else [
        console.log('Reprovado!')
      ]
    }
    
    imprimirResultado('Epa')
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4355bb1c-3313-4557-ab68-dc582e8dd20e/Untitled.png)
    
    O coisa certa a se fazer no Java Script, √© tratar estes ‚Äúacontecimentos‚Äù, travando para o usu√°rio n√£o poder informar ao sistema, dados que poder√£o dar resultados errados.
    

## Extrutura If & Else If & Else

Podemos encadear extruturas de If, If & Else, If & Else If em uma √∫nica extrutura de Controle

- Exemplos:
    
    
    Exemplo 01
    
    ```jsx
    Number.prototype.entre = function (inicio, fim) {
      return this >= inicio && this <= fim
    }
    
    const imprimirResultado = function(nota) {
      if(nota.entre(9, 10)) {
        console.log('Quadro de Honra!')
      } else if (nota.entre(7, 8.99)) {
        console.log('Aprovado!')
      } else if(nota.entre(4, 6.99)) {
        console.log('Recupera√ß√£o!')
      } else if(nota.entre(3, 3.99)) {
        console.log('Raprovado!')
      } else {
        console.log('Nota inv√°lida!')
      }
    }
    
    imprimirResultado(10)
    imprimirResultado(8.9)
    imprimirResultado(6.55)
    imprimirResultado(3.26)
    imprimirResultado(2.3)
    imprimirResultado(-1)
    imprimirResultado(11)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c434c668-c11d-46e9-a57b-00bdf2051718/Untitled.png)
    

## Extrutura Switch

Switch √© uma extrutura para multiplas escolhas, multiplas sele√ß√µes para cada caso em que o usu√°rio informar uma valor, a express√£o retorna o que o bloco de c√≥digo determinar.

*Antes, um ALERTA üí• - No java script, quando usamos Switch, n√£o podemo usar n√∫mero decimais e t√£o pouco express√µes com Operadores Atitim√©ticos, pois ele n√£o entende estas express√µes.*

*Por isso, repare que no bloco de c√≥digo a baixo, n√≥s utilizamos a propriedade Math.floor(Math.floor(nota)) para que o sistema pegue o valor indicado na variavel nota, e arredonde ele para baixo, caso o usu√°rio informe valores decimais.*

*N√£o aceita para sepra√ß√£o de case:*

- *case 3, 2, 1, 0*
- *case 3 - 5*
- *case (nota > 7)*

Exemplo 01

```jsx
const imprimirResultado = function(nota) {
  switch (Math.floor(nota)) {
    case 10:
    case 9:
      console.log('Quadro de Honra')
      break
    case 8: case 7:
      console.log('Aprovado!')
      break
    case 6: case 5: case 4:
      console.log('Recupera√ß√£o!')
      break
    case 3: case 2: case 1: case 0:
      console.log('Reprovado!')
      break
    default:
      console.log('Nota Invalida')
  }
}

imprimirResultado(10)
imprimirResultado(8.9)
imprimirResultado(6.55)
imprimirResultado(2.3)
imprimirResultado(-1)
imprimirResultado(11)
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/605c9f74-fc56-48d2-9f90-30be8e9b681a/Untitled.png)

                                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# EXTRUTURAS(LA√áOS) DE REPETI√á√ÉO

As extruturas de repeti√ß√£o servem para que um determinado bloco de c√≥digo seja repetido por v√°rias vezes at√© que a condi√ß√£o para isso seja atendida pelo c√≥digo.

### Extrutura While

Para mostrar como funciona este la√ßo de repeti√ß√£o, vamos criar uma fun√ß√£o randomica que ir√° ficar imprimindo na tela n√∫meros aleat√≥rios entre um intervalo de minimo e maximo que n√≥s iremos determinar, at√© que ele encontre o n√∫mero -1. Ao encontrar o n√∫mero menos um, a condi√ß√£o ser√° estabelecida e ent√£o o la√ßo ir√° parar. Vamos L√°?

```jsx
function getInteiroAleatorioEntre(min, max) {
  const valor = Math.random() * (max - min) + min
  return Math.floor(valor)
}

let opcao = 0

while (opcao != -1) {
  opcao = getInteiroAleatorioEntre(-1, 10)
  console.log(`Op√ß√£o escolhida foi ${opcao}.`)
}

console.log('At√© a pr√≥xima!')
```

Claro que as respostas ser√£o aleat√≥rias, a cada vez que rodarmos este c√≥digo. Mas a resposta neste caso agora foi esta:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92b79107-c289-4b6f-b267-5dd559a4d991/Untitled.png)

### Extrutura DoWhile

A grande difer√™n√ßa do While para o DoWhile √© que no DoWhile o programa ir√° executar pelo menos uma vez o la√ßo de repeti√ß√£o, indiferentemente se a condi√ß√£o for atendida para encerrar o la√ßo ou n√£o.

Na express√£o do while √© a √∫nica em que a condi√ß√£o de controle vai depois do bloco com chaves { }. Veja:

```jsx
function getInteiroAleatorioEntre(min, max) {
  const valor = Math.random() * (max - min) + min
  return Math.floor(valor)  
}

let opcao = -1;

do {
  opcao = getInteiroAleatorioEntre(-1, 10)
  console.log(`Op√ß√£o escolhida foi ${opcao}.`)
} while (opcao != -1)

console.log('At√© a Pr√≥xima!!!')
```

A difer√™n√ßa √© que no resultado, mesmo que o primeiro valor seja false para a condi√ß√£o, ele ir√° executar ao menos uma vez o while.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/46bf213f-74b2-41f1-8952-98bdb7bd7842/Untitled.png)

Reinterando, diferente da estrutura While, o Do/While n√£o √© necess√°rio atribuir um valor inicial para a vari√°vel¬†**opcao,**
¬†ou seja, fazendo assim:

```jsx
function getInteiroAleatorioEntre(min, max) {
    const valor = Math.random() * (max - min) + min
    return Math.floor(valor)
}
 
let opcao //somente iniciada a vari√°vel, sem valor inicial!
 
do {
    opcao = getInteiroAleatorioEntre(-1, 10)
    console.log(`Op√ß√£o escolhida foi ${opcao}.`)
} while (opcao != -1)
 
console.log('At√© a pr√≥xima!')
```

Fazendo isso, garante que a estrutura v√° rodar pelo menos uma vez.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c528fdb1-52b7-4e17-b31d-a3ed673d3a70/Untitled.png)

### Extrutura For

For √© uma extrutura de controle muito semelhante ao While, por√©m a grande difern√ßa √© que o For possui em sua express√£o de controle, tr√™s divis√µes, sendo elas:

1 = Declara√ß√£o / 2 = Condi√ß√£o / 3 = Incremento. Segue:

```jsx
for(let i = 1; i<= 10; i++) {
	console.log(`I = ${i}`)
}
```

Resultado:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75c27328-69b8-4fef-80a0-d44c09836890/Untitled.png)

Uma maneira muito costumeira de utilizar o For em uma aplica√ß√£o, √© para fazer com que ele percorra por exemplo uma Array, ou um Objeto, resgatando dados indice a indice. Para isso, basta fazer uma express√£o conforme a que segue a baixo:

```jsx
const notas = [6.7, 7.4, 9.8, 8.1, 7.7]

for(let i = 0; i < notas.length; i++) {
  console.log(`nota = ${notas[i]}`)
}
```

O resultado para esta express√£o seria este:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/14f835d0-1e5a-4dda-9e9c-da923ce97d5d/Untitled.png)

### Extrutura For In

Esta √© mais uma maneira de percorrer um array ou objeto e ou outras extruturas como estas, sendo que ao inv√©s de ele trazer os dados de cada elemento, ele tr√°s o indice de cada elemento percorrido. Para voc√™ obter os valores destes indices, ai √© preciso codificar isso na sua express√£o de ‚Äúimpress√£o‚Äù dos dados.

```jsx
const notas = [6.7, 7.4, 9.8, 8.1, 7.7]

for (let i in notas) {
  console.log(i, notas[i])
}
```

Este For In a cima tr√°s todos os indices do array, e tamb√©m os dados de cada elemento.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bbd011d0-a37f-4b89-a855-f32c2697741b/Untitled.png)

Tamb√©m √© possivel percorrer elementos de um objeto:

```jsx
const pessoa = {
  nome: 'Ana',
  sobrenome: 'Silva',
  idade: 29,
  peso: 64
}

for (let atributo in pessoa) [
  console.log(`${atributo} = ${pessoa[atributo]}`)
]
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/baeffabe-b4f5-4b94-babd-9c6e4b7e03d8/Untitled.png)

                                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# USANDO BREAK / CONTINUE

As duas express√µes causam a interrup√ß√£o do la√ßo de repeti√ß√£o. Por√©m, elas executam fun√ß√µes diferentes ap√≥s a interrup√ß√£o.

                                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

***Break ‚áí*** Como j√° vimos anteriormente, o break interrompe imeditamente o la√ßo quando a condi√ß√£o a ele √© imposta, saindo assim do la√ßo e partindo para novas intru√ß√µes. Exemplo:

```jsx
const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for(x in nums) {
  if (x == 5) {
    break
  }
  console.log(`${x} = ${nums[x]}`)
}
```

- Primeiro ponto importante nesta express√£o a cima, √© sempre ter em mente que o **BREAK** n√£o interfere na expre√ß√£o **IF**. O Break sempre ir√° interferir em la√ßos de repeti√ß√£o, e sempre no la√ßo mais pr√≥ximo a ele. Ou seja, neste caso, o **Break** esta atuando no la√ßo **FOR**.

Por fim, nesta express√£o a cima, ir√° retornar o indice e seus valores at√© chegar no indice 5. Chegando no indice 5, o sistema sai do la√ßo for.

Resultados:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8d3ef458-cbde-4c6a-9bb4-de69f63e3d6c/Untitled.png)

                                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

***Continue ‚áí*** O continue tamb√©m ir√° interromper o la√ßo mais pr√≥ximo a ele, s√≥ que a diferen√ßa √© que o continue interrompe o la√ßo mais pr√≥ximo a esta express√£o no momento em que a condi√ß√£o for atendida, por√©m, ele continua executando o la√ßo a partir da pr√≥ximo passo.

No exemplo a baixo iremos ver um array de de 10 n√∫meros e uma express√£o for percorrendo os elementos deste array, com a condi√ß√£o de parar quando o indice for igual a 5. E ent√£o continuar at√© o indice ser 10, conforme o la√ßo de repeti√ß√£o.

```jsx
const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

for (y in nums) {
  if(y == 5) {
    continue
  }
  console.log(`${y} = ${nums[y]}`)
}
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/11392149-11fb-4d94-8947-894a8699b475/Untitled.png)

## üí• ***INFORMA√á√ÉO!!!***

Como informei, o break e o continue sempre ir√£ atuar no la√ßo de repeti√ß√£o mais pr√≥ximo a ele. Sendo assim, se tivermos dois ou mais la√ßos de repeti√ß√£o, um dentro de outro, e colocarmos o break por exemplo no ultimo la√ßo de dentro, este break somente ir√° atuar neste √∫ltimo la√ßo.

Para que possamos vincular um break a um la√ßo mais externo, √© preciso utilizar uma express√£o chamada de r√≥tulo. Olhe o exemplo:

```jsx
//Criamos o rotulo chamado de "externo"
externo: for (a in nums) {
	for (b in nums) {
		if(a == 2 && b == 3) break externo
		console.log(`Par = ${a}, ${b}`)
	}
}

console.log('Fim!')
```

Resultado:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d0175d3-9d14-4b1f-b41c-4367df3d26f3/Untitled.png)

                                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# FUN√á√ïES

Fun√ß√£o √© uma express√£o que pode criar dados, criar novas fun√ß√µes, retornar qualquer express√£o como dados.

```jsx
// Criar de forma literal
function fun1() {

}
```

* Como pontos positivos e determinantes, √© possivel armazenar fun√ß√µes em variaveis par reutilizar em outro lugar da aplica√ß√£o;

```jsx
//Armazenar em uma variavel
const fun2 = function () {}
```

* Tamb√©m podemos armazenar fun√ß√µes em array;

```jsx
//Armazenar em um array
const array = [
  function (a, b) {return a + b},
  fun1, 
  fun2
]
console.log(array[0](2, 3))
```

* Podemos armazenar como parametros de objetos;

```jsx
//Armazenar em um atributo de objetos
const obj = {}
obj.falar = function () { return 'Opa!'}
console.log(obj.falar())
```

* Podemos passar a fun√ß√£o como parametro para outra fun√ß√£o;

 

```jsx
//Passar fun√ß√£o como paramentro para outra Fun√ß√£o
function run(fun) {
  fun()
}

run(function () { console.log("Executando...")})
```

* Uma fun√ß√£o pode retornar ou conter outra fun√ß√£o;

```jsx
//Uma fun√ß√£o pode retornar/conter uma fun√ß√£o
function soma(a, b) {
  return function (c) {
    console.log(a + b + c)
  }
}

soma(2, 3)(4)
//Ou
const cincoMais = soma(2, 3)
cincoMais(4)
```

* Toda fun√ß√£o tem o array interno **arguments** disponivel, e inclusive podemos pegar os parametros de dentro deste array, da seguinte forma;

```jsx
function soma(){
  let soma = 0
  for (i in arguments) {
    soma += arguments[i]
  }
  return soma
}

console.log(soma())
console.log(soma(1))
console.log(soma(1.1, 2.2, 3.3))
console.log(soma(1.1, 2.2, "Teste"))
console.log(soma("a", "b", "c"))
```

                                                                                                                      [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## ***Fun√ß√µes - Parametros Padr√£o / Default***

O valor default (padr√£o) para a fun√ß√£o com parametros num√©ricos, √© o valor que retornar√° para o usu√°rio caso o retorno da fun√ß√£o n√£o seja um n√∫mero v√°lido ou ent√£o o retorno seha undefyned.

Temos v√°rias estrat√©gias para usar, para previnir ‚Äòbugs‚Äô com retornos underfyned ou NaN.

```jsx
// Estrategia 1 para gerar valor padr√£o
function soma1(a, b, c) {
  a = a || 1
  b = b || 1
  c = c || 1

  return a + b + c
}

console.log(soma1(), soma1(3), soma1(1, 2, 3), soma1(0, 0, 0))
```

Nesta primeira estrat√©gia, conseguiremos resolver caso os valores dos parametros sejam underfyned. Por√©m, se o problema aqui √© que se for n√∫meros Zero por exemplo, o sistema ir√° entender que os valores devem ser 1 para cada variavel, e o resultado de 0 + 0 + 0 = 3, o que n√£o √© correto.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e6f59647-fd7f-4ed2-b901-137d421ef3c9/Untitled.png)

```jsx
// estrategia 2, 3 e 4 para gerar valor padr√£o
function soma2(a, b, c) {
  a = a !== undefined ? a : 1
  b = 1 in arguments ? b : 1
  c = isNaN(c) ? 1 : c //Melhor estrat√©gia a ser utilizada

  return a + b + c
}

console.log(soma2(), soma2(3), soma2(1, 2, 3), soma2(0, 0, 0))
```

Nesta fun√ß√£o j√° colocamos direto 3 estrat√©gias diferentes, sendo que a melhor √© a ultima. Pois nela, tudo o que n√£o for n√∫mero, ser√° considerado 1. E ent√£o teremos os resultados padr√µes mais corretos.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3060925e-784b-448f-8c25-c7c1fe075e64/Untitled.png)

E por √∫ltimo, a estrat√©gia que passamos a utiliza ap√≥s atualiza√ß√£o do ES2015

```jsx
//Valor padr√£o do ES2015
function soma3( a = 1, b = 1, c = 1 ) {
  return a + b + c
}

console.log(soma3(), soma3(3), soma3(1, 2, 3), soma3(0, 0, 0))
```

Resultado final de todas elas:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8f5af50f-d40c-4d8c-b8a9-8aa97d1d2e82/Untitled.png)

                                                                                                                      [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## ***Fun√ß√µes - This (Recurso)***

√â uma das palavras reservadas no JS para refer√™nciar o objeto atual da execu√ß√£o no contexto que a palavra ***this*** se encontra.

Normalmente o this costuma variar em rela√ß√£o as fun√ß√µes. Isso depender√° sempre de como voc√™ ir√° acessar a fun√ß√£o.

Obs.: Por√©m, em toda a Fun√ß√£o Arrow o this sempre ir√° se referir a esta fun√ß√£o criada.

**# this e a fun√ß√£obind**

Acompanhe o objeto e a fun√ß√£o falar( ) dentro deste objeto:

```jsx
const pessoa = {
  saudacao: 'Bom dia!',
  falar() {
    console.log(this.saudacao)
  }
}

pessoa.falar()
```

Veja que na fun√ß√£o falar( ) a cima, tivemos que usar o ***this*** para poder acessar o conteudo do parametro **saudacao** que se encontra dentro do objeto **pessoa**.

Isso significa que sem o ***this***, o JS n√£o ir√° reconhecer o parametro **saudacao**, pois dentro da fun√ß√£o falar( ), este parametro n√£o existe.

                                                                                                                [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# Entendendo o uso da fun√ß√£o Bind!!

Se n√≥s instaciar-mos o objeto com a sua fun√ß√£o para uma variavel, quando terntarmos executar esta fun√ß√£o, ir√° dar um problema, pois o this.saudacao n√£o ser√° mais encontrado em nenhum contexto nesta express√£o. O sistema n√£o ir√° sabe para onde o this esta apontando.

Para resolver isso, n√≥s criamos uma outra variavel, e nela identificamos para qual contexto o this deve apontar, quando o sistema se perder neste trajeto.

```jsx
const pessoa = {
  saudacao: 'Bom dia!',
  falar() {
    console.log(this.saudacao)
  }
}

const falar = pessoa.falar
falar() //Aqui conflita paradigmas entre funcional e Orienta√ß√£o a Objetos
```

No caso a cima se tentar rodar a fun√ß√£o falar, ela n√£o ir√° funcionar, pois o this.saudacao neste caso aponta para lugar nenhum.

Como foi dito antes, para resolver isso, utilizamos a fun√ß√£o **bind**. segue:

```jsx
const pessoa = {
  saudacao: 'Bom dia!',
  falar() {
    console.log(this.saudacao)
  }
}

const falarDepessoa = pessoa.falar.bind(pessoa)
falarDepessoa()
```

Isso significa que para maior seguran√ßa, usamos bind para garantir a qual componente estamos tentando acessar na fun√ß√£o.

### Outro momento em que o this n√£o √© localizado √© o que segue a baixo.

Vamos criar uma fun√ß√£o pessoa com o paramentro idade. Depois vamos criar uma outra fun√ß√£o **serInternal( ) { }** que ir√° ficar incrementando de um em um, conforme condi√ß√µes de determinamos a ela, com o intervalo de tempo que tamb√©m determimos para ela em mile segundos.

```jsx
function Pessoa() {
  this.idade = 0

  setInterval(function() {
    this.idade++
    console.log(this.idade)
  }, 1000)
}

new Pessoa
```

Ao executar esta fun√ß√£o, (**Ctrl + Alt + N**) executa & (**Ctrl + Alt + M**) para, iremos ter como retorno um NaN. Pois a fun√ß√£o n√£o consegue compreender a qual parametro esta se referindo o **this**.

para resolver isso, podemos fazer o bind:

```jsx
function Pessoa() {
  this.idade = 0

  setInterval(function() {
    this.idade++
    console.log(this.idade)
  }.bind(this), 1000)
}

new Pessoa
```

Outra maneira, podemos utilizar a palavra reserva self para fazer o trabalho do bind. Iremos armazer o this dentro do self, e assim o this sempre ir√° apontar para o lugar correto.

```jsx
function Pessoa1() {
  this.idade = 0

  const self = this

  setInterval(function() {
    self.idade++
    console.log(self.idade)
  }, 1000)
}

new Pessoa1
```

                                                                                                                      [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## ***Fun√ß√µes Arrow***

Esta foi criada com dois objetivos:

1. Reduzir ao m√°ximo a sintaxe das fun√ß√µes;
2. Fazer com que o ***this*** seja asociado de forma definitiva a esta fun√ß√£o, conforme ela for descrita;

Exemplos:

```jsx
// Fun√ß√£o descrita normal
let dobro = function (a) {
  return 2 * a
}

// Fun√ß√£o Arrow
dobro = (a) => {
  return 2 * a
}

// Fun√ß√£o Arrow mais reduzida se ela tiver apenas um parametro
dobro = a => 2 * a // return esta implicito
console.log(dobro(Math.PI))
```

Mais exemplos:

```jsx
// Fun√ß√£o Nomal
let ola = function () {
  return '√ìla'
}

// Fun√ß√£o Arrow
ola = () => 'Ol√°'
ola = _ => 'Ol√°' // Possui parametro tamb√©m
console.log(ola())
```

                                                                                                                [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

**### This dentro de uma fun√ß√£o arrow**

Usando o exemplo da fun√ß√£o Pessoa contendo .bind como auxilio para identificar o This, n√≥s agora vamos criar uma fun√ß√£o arrow, onde n√£o precisaremos do bind, porque, por se tratar de uma fun√ß√£o arrow, o this n√£o varia conforme onde chamamos a fun√ß√£o. Ele sempre ir√° se referir a fun√ß√£o pessoa. Segue:

```jsx
function Pessoa() {
  this.idade = 0

  setInterval(() => {
    this.idade++
    console.log(this.idade)
  }, 1000)
}

new Pessoa
```

Efeito do bind na Arrow Function

```jsx
// Fun√ß√£o normal
let comparaComThis = function (param) {
  console.log(this === param)
}

comparaComThis(global)

const obj = {}
comparaComThis = comparaComThis.bind(obj)
comparaComThis(global)
comparaComThis(obj)

//Fun√ß√£o Arrow
let comparaComThisArrow = param => console.log(this === param)
comparaComThisArrow(global)
comparaComThisArrow(module.exports)
```

Resultados:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ba264e33-a26c-46e0-93ab-af9f56ecf73a/Untitled.png)

**Curiosidade!!**

Entre uma arrow function e um .bind, quem tem mais for√ßa sobre o this?

Sempre a arrow function

```jsx
comparaComThisArrow = comparaComThisArrow.bind(obj)
comparaComThisArrow(obj)
```

                                                                                                                      [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## ***Fun√ß√µes An√¥nimas***

Fun√ß√£o an√¥nima √© simplesmente uma fun√ß√£o sem nome.

Seguem exemplos:

```jsx
const soma = function (x, y) {
  return x + y
}

const imprimirResultado = function (a, b, operacao = soma) {
  console.log(operacao(a, b))
}

imprimirResultado(3, 4)
imprimirResultado(3, 4, soma)
imprimirResultado(3, 4, function(x, y) {
  return x - y
})
imprimirResultado(3, 4, (x, y) => x * y)

const pessoa = {
  falar: function () {
    console.log('Opa!')
  }
}

pessoa.falar()
```

                                                                                                                [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

                                                                                                                      [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## ***Fun√ß√µes CallBack***

As fun√ß√µes callback, s√£o aquelas que podem ser chamadas pela aplica√ß√£o por diversas vezes, dependendo do contexto da sua express√£o.

```jsx
const fabricantes = ["Mercedes", "Audi", "BMW"]

function imprimir(nome, indice) {
  console.log(`${indice + 1}. ${nome}`)
}

fabricantes.forEach(imprimir)
```

Neste exemplo a cima, temos um array onde a fun√ß√£o callback ‚Äúimprimir‚Äù ir√° ser chamada pela fun√ß√£o forEach toda vez que ela passar por um elemento deste array.

Ou seja, como resultado deste bloco de c√≥digos a cima √©:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84251fe4-1fe8-4642-9b7d-be25fbe6c82e/Untitled.png)

Ainda, pode ser impresso somente os dados deste array, sem o indice. Podendo ser em uma fun√ß√£o normal ou fun√ß√£o Arrow.

```jsx
// Fun√ß√£o Normal
fabricantes.forEach(function(fabricante) {
  console.log(fabricante)
})
// Fun√ß√£o Arrow
fabricantes.forEach(fabricante => console.log(fabricante))
```

Os Resultados ser√£o iguais:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa2cf191-1bc0-4ad5-b173-1cf32656a5ce/Untitled.png)

* Vamos agora fazer um exemplo onde teremos a fun√ß√£o normal e a fun√ß√£o callBack, para identificarmos a grande diferen√ßa da utiliza√ß√£o de uma fun√ß√£o callBack.

**Exemplo01.**

```jsx
const notas = [7.7, 6.5, 5.2, 8.9, 3.6, 7.1, 9.0]

// //Imprimir as notas do Array que s√£o menores do que 7.0
// // Sem callBack
const notasBaixas1 = []
for(let i in notas) {
  if(notas[i] < 7) {
    notasBaixas1.push(notas[i])
    //.push √© uma fun√ß√£o para inserir elementos no array
  }
}
console.log(notasBaixas1)
```

Neste exemplo a cima utilzamos o for para percorrer os elementos do array notas, e salvar em um novo array (notasBaixas), e o if para por somente as notas menores do que 7.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/515c2bdc-6644-4ff4-8052-1137dd06f335/Untitled.png)

**Exemplo2.**

```jsx
const notas = [7.7, 6.5, 5.2, 8.9, 3.6, 7.1, 9.0]

//Com CallBack
const notasBaixas2 = notas.filter(function (nota) {
  return nota < 7
})
console.log(notasBaixas2)
```

Bem, com a fun√ß√£o callBack n√≥s poderemos reduzir drasticamente o bloco de c√≥digos. No exemplo 2 logo a cima n√≥s fizemos os seguintes passos:

**>** Criamos implicitamente um array notasBaixas2 que ir√° receber todas as notas que atenderem as condi√ß√µes que iremos inserir. Neste caso ser√£o notas menores do que 7;

**>** Usamos a fun√ß√£o notas.filter( );

- Fun√ß√£o **filter**( )
    
    A fun√ß√£o¬†**Filter**
    ¬†recebe como par√¢metro uma fun√ß√£o de callback, onde o retorno dado ser√° um novo array com os elementos que passaram na valida√ß√£o realizada. Lembrando que o array original n√£o √© alterado, trazendo assim um dos conceitos da programa√ß√£o funcional.
    

**>** Dentro da fun√ß√£o filter, inserimos como parametro uma ***fun√ß√£o callBack*** que ir√° percorrer os elementos dentro do array nota, sob a condi√ß√£o de que se a nota (valor) for menor do que 7, esta fun√ß√£o ir√° inserir esta nota (valor) no novo array notasBaixa2.

Resultado:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90841e87-5674-492b-bba9-586d665d111c/Untitled.png)

- **Exemplo3. (Com callBack + Arrow Function)**
    
    
    *Para deixar tudo ainda mais simples, vamos fazer o mesmo exemplo, mas agora utilizaremos **filter( )** + **callBack** como parametro e tudo dentro de uma **Arrow Function**.*
    
    ```jsx
    const notas = [7.7, 6.5, 5.2, 8.9, 3.6, 7.1, 9.0]
    
    // Com callBack e Arrow function
    const notasBaixas3 = notas.filter(nota => nota < 7)
    console.log(notasBaixas3)
    ```
    
    E o Resultado ser√° exatamente igual aos outros 2 exemplos:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2364a91b-eb48-4076-bd85-bff5696a7218/Untitled.png)
    
    Entendo melhor:
    
    **callBack ‚áí (nota = > nota < 7)**
    
    - ***nota*** = parametro para receber o valor de cada elemento do array notas;
    - ***nota < 7*** = Condi√ß√£o que retorna uma das duas situa√ß√µes:
        - **Verdadeiro >>** Caso o valor do elemento filtrado do array notas for menor do que 7;
        - **Falso >>** Caso o valor do elemento filtrado do array notas seja maior do que 7;
        
        Conforme o resultado a cada .filter( ) feito em cada elemento do array, se verdareiro, o elemento entra no novo array notasBaixas, se falso, n√£o entra.
        
        Detalhe. Esta fun√ß√£o n√£o altera nada no primeiro array, que no caso √© o notas.
        
                                                                                                           [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
        

                                                                                                                      [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## ***Fun√ß√µes Construtoras***

S√£o fun√ß√µes que utilizamos para estanciar em quantos objetos n√≥s quisermos, de forma a utiliza-l√°, para atualizar os dados destes objetos.

Vamos utilizar como exemplo, uma fun√ß√£o construtora carro, que receber√° dados de velocidade para irmos atualizando a acelera√ß√£o de objetos (carros).

```jsx
function Carro(velocidadeMaxima = 200, delta = 5) {
  // atributo privado
  let velocidadeAtual = 0

  // metodo publico
  this.acelerar = function () {
    if (velocidadeAtual + delta <= velocidadeMaxima) {
      velocidadeAtual += delta
    } else {
      velocidadeAtual = velocidadeMaxima
    }
  }

  // metodo publico
  this.getVelocidadeAtual = function () {
    return velocidadeAtual
  }
}

const uno = new Carro
uno.acelerar()
console.log(`Uno acelerou ${uno.getVelocidadeAtual()}Km`)

const ferrari = new Carro(350, 20)
ferrari.acelerar()
ferrari.acelerar()
ferrari.acelerar()
console.log(`Ferrari acelerou ${ferrari.getVelocidadeAtual()}Km`)

console.log(typeof Carro)
console.log(typeof ferrari)
```

Resultados:

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0e45f229-476b-4ed6-b5fb-98cc0e4fdd75/Untitled.png)

                                                                                                                      [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## ***Tipos de Declara√ß√µes de Fun√ß√µes***

Seguem algumas formas de se declarar fun√ß√µes em Java Script.

```jsx
console.log(soma(3, 4))

// function declaration
//(S√£o fun√ß√µes declaradas antes mesmo de executar o c√≥digo)
function soma(x, y) {
  return x + y
}

// function expression
const sub = function (x, y) {
  return x - y
}
console.log(sub(3, 4))

// named function expression
const mult = function mult(x, y) {
  return x * y
}
console.log(mult(3, 4))
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/68defa3d-243d-46ff-9c7f-a7dc72393ada/Untitled.png)

Temos outras maneiras de Chamar(executar) uma fun√ß√£o em JS

# **Call ou Apply**

```jsx
function getPreco(imposto = 0, moeda = 'R$') {
  return `${moeda} ${this.preco * (1 - this.desc) * (1 + imposto)}`
}

const produto = {
  nome:'Noteboock',
  preco: 4589,
  desc: 0.15,
  getPreco
}

global.preco = 20
global.desc = 0.1
console.log(getPreco())
console.log(produto.getPreco())

const carro = {preco: 49990, desc: 0.20}

console.log(getPreco.call(carro))
console.log(getPreco.apply(carro))

console.log(getPreco.call(carro, 0.17, '$')) // Invocar com .call
console.log(getPreco.apply(carro, [0.17, '$'])) // Invocar com .apply
```

                                                                                                                      [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## ***Fun√ß√µes Factory***

√â uma fun√ß√£o que retorna(fabr√≠ca) um objeto.

**Exemplo01.**

```jsx
// Factory Simples
function criarPessoa() {
  return {
    nome: 'Ana',
    sobrenome: 'Silva'
  }  
}

console.log(criarPessoa())
```

**Exemplo02.**

```jsx
function criarProduto(nome, preco) {
  return {
    nome,
    preco,
    desconto: 0.1
  }
}

console.log(criarProduto('Noteboock', 2199,49))
console.log(criarProduto('iPad', 1199,49))
```

                                                                                                                      [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

## ***Fun√ß√µes IIFE***

IIFE => Immediately Invoked Function Expression

S√£o fun√ß√µes auto invocadas. Ao seja, ela j√° √© invocada no mesmo boclo de invoca√ß√£o da mesma.

Ela serve para evitar manipula√ß√µes diretas no escopo global, ou seja, ela faz altera√ß√µes que s√£o geradas dentro do scopo da fun√ß√£o.

```jsx
// IIFE => Immediately Invoked Function Expression
(function() {
  console.log('Ser√° executado na hora!')
  console.log('Foge do escopo mais abrangente!')
})()
```

                                                                                                                [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# COMPARA√á√ÉO ENTRE STRING & NUMEROS

Acontece dentro do Javascript a compara√ß√£o entre n√∫meros em formato string.

Abaixo temos uma cadeia string de n√∫meros.

`1. const cadeia_de_strings = '1, 2, 3, 4, 5, 6, 7, 8, 9'`

Se pegarmos alguns dos valores da cadeia de strings e fizermos a compara√ß√£o entre nossas strings de n√∫mero at√© o nove, ela mantem um comportamento normal. Como se estiv√©ssemos comparando n√∫meros.

`1. '1' > '2'
2. //output : false
3. '1' > '1'
4. //output : false
5. '2' > '1'
6. //output : true
7. '4' > '2'
8. //output : true`

Agora se compararmos os valores depois do nove, a compara√ß√£o ir√° validar o primeiro n√∫mero da cadeia numeral, validando sua ordem alfab√©tica. Por exemplo:

`1. '2' > '12'
2. //output : true
3. '5' > '42'
4. //output : true
5. '3' > '29'
6. //output : true`

Com isso, podemos ver que n√£o √© uma abordagem muito boa comparar n√∫meros em formato de string.

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# ORIENTA√á√ÉO A OBJETOS

- **Maneiras de criar objetos:**
    
    Vamos entender quais as maneiras que temos para criar um novo objeto em JS.
    
    - ***Forma Literal ‚áí*** A maneira mais convencional para criar um objeto √© de forma literal. Ou seja, usando as chaves { }:
    
    ```jsx
    // Usando a nota√ß√£o literal
    const obj1 = {}
    console.log(obj1)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dbe915ab-7f2d-46eb-9bbe-d7b2f91effa4/Untitled.png)
    
    Outras formas literais de criar objeto:
    
    ```jsx
    // ANOTA√á√ÉO LITERAL DE OBJETOS - ES2015
    const a = 1
    const b = 2
    const c = 3
    
    /* ************************************ */
    // Antigamente era assim
    const obj1 = {a: a, b: b, c: c}
    // Agora
    const obj2 = {a, b, c}
    console.log(obj1, obj2)
    /* ************************************ */
    
    /* ************************************ */
    // Antes era assim
    const nomeAtributo = 'nota'
    const valorAtributo = 7.87
    const obj3 = {}
    obj3[nomeAtributo] = valorAtributo
    console.log(obj3)
    
    //Agora √© assim
    const obj4 = {[nomeAtributo]: valorAtributo}
    console.log(obj4)
    /* ************************************ */
    
    /* ************************************ */
    // Definindo fun√ß√µes dentro do objeto (Antes)
    const obj5 = {
      funcao1: function() {
    
      },
      // // Definindo fun√ß√µes dentro do objeto (Agora)
      funcao2() {
    
      }
    }
    console.log(obj5)
    /* ************************************ */
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/177da596-72ea-4d2a-98be-833c5d63219d/Untitled.png)
    
    - ***Utilizando a fun√ß√£o Object ‚áí*** Outra forma muita utilizada, √© utilizando a fun√ß√£o Object do pr√≥prio JS. Podemos perceber no c√≥digo a baixo, que se imprimimos na tela o tipo do Object e o tipo do **new** Object, iremos ter respectivamente uma ***fun√ß√£o*** e depois um ***objeto***.
    
    ```jsx
    // Usando a fun√ß√£o Object como construtura
    console.log(typeof Object, typeof new Object)
    const obj2 = new Object
    console.log(obj2)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e22c0f31-cfee-41e5-acac-ab4418bacd0e/Untitled.png)
    
    - ***Utilizando fun√ß√µes Construtoras ‚áí*** Ainda, podemos criar fun√ß√µes pr√≥prias que podem ser visiveis para qualquer local da aplica√ß√£o que desejarmos. Segue sintaxe para criar Objeto desta forma:
    
    ```jsx
    // Atrav√©s de Fun√ß√µes Construtoras
    function Produto(nome, preco, desc) {
      this.nome = nome
      this.getPrecoComDesconto = () => {
        return preco * (1 - desc)
      }
    }
    
    const p1 = new Produto('Caneta', 7.99, 0.15)
    const p2 = new Produto('Noteboock', 2998.99, 0.25)
    console.log(p1.getPrecoComDesconto(), p2.getPrecoComDesconto())
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/198aec31-a15b-4302-a7c7-7498d3f65be5/Untitled.png)
    
    - ***Utilizando fun√ß√µes Factores ‚áí*** Fun√ß√µes factoris, s√£o fun√ß√µes que criam alguma coisa dentro do nosso sistema. Vamos criar uma fun√ß√£o que ir√° ‚Äúcriar‚Äù cadastro de funcion√°rio sempre que ela for acionada:
    
    ```jsx
    // Usando uma Fun√ß√£o Factory
    function criarFuncionario(nome, salarioBase, faltas) {
      return {
        nome,
        salarioBase,
        faltas,
        getSalario() {
          return (salarioBase / 30) * (30 - faltas)
        }
      }
    }
    
    const f1 = criarFuncionario('Jo√£o', 7980, 4)
    const f2 = criarFuncionario('Maria', 11400, 1)
    console.log(f1.getSalario(), f2.getSalario())
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cdb0febc-eefd-4f48-b89b-e9ac0c8da024/Untitled.png)
    
    - ***Utilizando Object.create ‚áí***
    
    ```jsx
    // Usando Object.create
    const filha = Object.create(null)
    filha.nome = 'Ana'
    console.log(filha)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4f77ab25-576c-4e9e-8aa0-866cabf94222/Untitled.png)
    
    - ***Utilizando uma fun√ß√£o que retorna Objeto ‚áí*** Uma fun√ß√£o muita utilizada em JS para transformar fun√ß√£o em Objeto, √© quando utilizamos por exemplo informa√ß√£r de webServer para serem resgatadas ou transmitidas em formato JSON. Ou seja, formato String.
    
    ```jsx
    // Utilizando uma Fun√ß√£o que retorna um Objeto
    const formJSON = JSON.parse('{"info": "Sou um JSON"}')
    console.log(formJSON.info)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/86da22da-7ead-4a96-aab0-17ab12efd46d/Untitled.png)
    
                                                                                                                         [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    
- **Entendendo Objetos ‚ÄúConstantes‚Äù:**
    
    Quando criamos um objeto e colocamos ele dentro de uma variavel constante, √© para que entendamos que este objeto dever√° apontar sempre para o mesmo espa√ßo de mem√≥ria, ou seja, ele nunca poder√° mudar o local de armazenamento deste Objeto.
    
    Por√©m, √© possivel mudar qualquer dado que tiver dentro deste objeto, nesta posi√ß√£o de mem√≥ria.
    
    ```jsx
    // Pessoa aponta ==> para um endere√ßo de mem√≥mira 123 = {...}
    const pessoa = { nome: 'Jo√£o'}
    pessoa.nome = 'Pedro'
    console.log(pessoa)
    ```
    
    Repare o resultado logo a baixo, e ir√° ver que o objeto pessoa foi criado e dentro dele foi iniciado o nome Jo√£o. O c√≥digo seguir alterou o nome para Pedro e na impress√£o saiu o ultimo nome criado.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0706482c-ec36-49bd-8ca8-3e1d8029b66a/Untitled.png)
    
    Ent√£o, a nivel de conhecimento, para tornar um Objeto para que ele e todos os elementos dentro dele fiquem ‚ÄúConstantes‚Äù, ou seja, para que nada no Obejto possa ser alterado, ent√£o teremos que usar o c√≥digo . freeze ‚áí Que √© um c√≥digo que congela o Obejto toda em si para altera√ß√µes.
    
    ```jsx
    Object.freeze(pessoa)
    ```
    
- **Getters & Setters:**
    
    S√£o fun√ß√µes que servem para ler ou escrever dados que s√£o privados dentro de objetos.
    
    ```jsx
    const sequencia = {
      _valor: 1, // Se convencionou colocar anderlayne em vari√°veis que s√£o restritas aos objetos
      get valor() { return this._valor++ }, // Ir√° retornar o valor + 1
      set valor(valor) {
         if(valor > this.valor) {
           this._valor = valor
         }
        }
    }
    
    console.log(sequencia.valor)
    console.log(sequencia.valor)
    sequencia.valor = 1000
    console.log(sequencia.valor, sequencia.valor)
    ```
    
- **Fun√ß√µes Importantes dentro de Object:**
    
    S√£o fun√ß√µes que todo objeto em JS possui com objetivo de auxiliar no tratamento das chaves e valores do obejto.
    
    A partir do objeto a baixo, vamos ver algumas fun√ß√µes que ir√£o fortalecer seu c√≥digo JS.
    
    ```jsx
    const pessoa = {
      nome: 'Rebeca',
      idade: 2,
      peso: 13
    }
    ```
    
    - Fun√ß√£o Object.keys ‚áí Fun√ß√£o que retorna quais s√£o as ‚Äúchaves‚Äù do objeto.
        - Exemplo:
        
        ```jsx
        const pessoa = {
          nome: 'Rebeca',
          idade: 2,
          peso: 13
        }
        console.log(Object.keys(pessoa))
        ```
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5924993a-5161-4c0e-8a59-cdf74b4254ac/Untitled.png)
        
    - Fun√ß√£o Object.values ‚áí Fun√ß√£o que retorna os valores dos elementos
    
    ```jsx
    const pessoa = {
      nome: 'Rebeca',
      idade: 2,
      peso: 13
    }
    console.log(Object.values(pessoa))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/449b361e-e223-497c-a674-753708680404/Untitled.png)
    
    - Fun√ß√£o Object.entries ‚áí Fun√ß√£o que retorna um ‚ÄúArray‚Äù maior com arrays menores dentro dele, contendo Chave e valor de cada elemento.
        
        ```jsx
        const pessoa = {
          nome: 'Rebeca',
          idade: 2,
          peso: 13
        }
        console.log(Object.entries(pessoa))
        ```
        
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8f9888d-7604-43cc-bfb4-afe8f62b1c19/Untitled.png)
    
    - Fun√ß√£o Object.entries( ).forEach ‚áí Fun√ß√£o que retorna os elementos do objeto em formato chave valor.
        
        ```jsx
        const pessoa = {
          nome: 'Rebeca',
          idade: 2,
          peso: 13
        }
        Object.entries(pessoa).forEach( e => {
          console.log(`${e[0]}: ${e[1]}`)
        })
        ```
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b1ac8ae7-57d0-4e75-9da2-94f0be19a6bd/Untitled.png)
        
    
    - Fun√ß√£o Object.entries( ).forEach **com DESTRUCTURING** ‚áí Fu√ß√£o que retorna os mesmo resultado do forEache ai de cima, por√©m com uma sintaxe reduzida.
        
        ```jsx
        const pessoa = {
          nome: 'Rebeca',
          idade: 2,
          peso: 13
        }
        //Destructuring
        Object.entries(pessoa).forEach(([chave, valor]) => {
          console.log(`${chave}: ${valor}`)
        })
        ```
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/74376f67-21a0-4239-b43c-b345a43e09aa/Untitled.png)
        
    - Fun√ß√£o Object.defineProperty( ) {  } ‚áí Fun√ß√£o que √© usada para definir propriedades para o Objeto, extruturando este objeto de forma que consiga definir se esta propriedade √© acessivel ou n√£o, √© visivel ou n√£o ou qualquer outra configura√ß√£o.
        
        ```jsx
        const pessoa = {
          nome: 'Rebeca',
          idade: 2,
          peso: 13
        }
        Object.defineProperty(pessoa, 'dataNascimento', {
          enumerable: true,
          writable: false,
          value: '01/01/2019'
        })
        pessoa.dataNascimento = '01/01/2017'
        console.log(pessoa.dataNascimento)
        ```
        
        *** Neste c√≥digo a cima, n√≥s criamos uma nova propriedade ‚ÄòdataNascimento‚Äô para o Objeto **pessoa**. E em seguida, definimos para esta propriedade as seguintes instru√ß√µes:
        
        1. ***enumerable:*** true ‚áí Significa que o elemento poder√° ser enumerado, impresso na tela. Ou seja, esta chave vai existir e poder√° ser vizualisada em tela. Se por false, significa que ela ir√° existir, mas ao usar o comando console.log(**Object**.keys(pessoa)) por exemplo, esta chave n√£o ser√° vizualisada em tela;
            
            ```jsx
            const pessoa = {
              nome: 'Rebeca',
              idade: 2,
              peso: 13
            }
            console.log(Object.keys(pessoa))
            
            Object.defineProperty(pessoa, 'dataNascimento', {
                enumerable: false,
                value: '01/01/2019'
              })
              console.log(pessoa.dataNascimento)
              console.log(Object.keys(pessoa))
            ```
            
            ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a79b01ca-1066-4b33-a67f-432bd1fe1451/Untitled.png)
            
            Percebendo o c√≥digo a cima e seu resultado, ir√° entender que criamos um novo elemento chamado dataNascimento, ele existe l√° dentro pois foi emitido seu valor em tela (*01/01/2019*), por√©m ao tentar listas todas as chaves, pela prpriedade ter a configura√ß√£o *enumerable* = false, este elemento n√£o √© exibido em tela.
            
        
        1. ***writable:*** false ‚áí Significa que o elemento n√£o poder√° ter ser valor substituido;
        2. ***value:** ‚Äò01/01/2019‚Äô* ‚áí Inserimos neste elemento o valor data;
        
        Veja logo ap√≥s no restante do c√≥digo que tentamos mudar o valor da data para *‚Äò01/01/2017‚Äô*, mas n√£o foi possivel, porque configuramos *writable* como false.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2b0f99e3-6a66-423c-aff9-b09805f97721/Untitled.png)
        
    - Fun√ß√£o Object.assign( ) ‚áí Fun√ß√£o que junta dados de dois ou mais objetos em um √∫nico objeto, recebendo como elementos os valores dos objetos indicados.
        
        O grande deltalhe √© que se tentarmos juntar elementos de dois objetos que possuem a mesma chave, esta fun√ß√£o ir√° sobescrever com o ultimo valor informado na sintaxe.
        
        Sintaxe ‚áí Object.assign(‚Äùobjeto que ir√° juntar os demias‚Äù, e os demais obejtos que ser√£o concatenados, separados por v√≠rgula) Segue:
        
        ```jsx
        // OBJECT.ASSIGN (ECMAScript 2015)
        const objetoDestino = { a: 1 }
        const obj1 = { b: 2 }
        const obj2 = { c: 3, a: 4 }
        const obj = Object.assign(objetoDestino, obj1, obj2)
        
        console.log(objetoDestino)
        console.log(obj1)
        console.log(obj2)
        ```
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b58b7488-43ea-4631-afa4-1e6b7c4b1759/Untitled.png)
        
        **### Primeira Observa√ß√£o:** Perceba que juntamos no Objeto chamado objetoDestino, todos os elementos dos objetos obj1 e obj2.
        
        **### Segunda Observa√ß√£o:** Perceba que no obj1 e obj2 temos 1 elemento de mesma chave **a:**. e como resultado no objetoDestino, o elemento do obj2 por ser o √∫ltimo, sobreescreveu o valor do elemento do obj1.
        
        **### √öltima Observa√ß√£o:** Perceba que os valores dos obj1 e obj2 n√£o s√£o alterados ao utilizar a fun√ß√£o **.assingn**
        
    - Fun√ß√£o Object.freeze( ) ‚áí Fun√ß√£o que congela todo o Objeto e todos seus elementos para qualquer tipo de altera√ß√£o. Ou seja, nada neste Objeto poder√° ser alterado a partir deste c√≥digo.
    
    ```jsx
    // OBJECT.ASSIGN (ECMAScript 2015)
    const objetoDestino = { a: 1 }
    const obj1 = { b: 2 }
    const obj2 = { c: 3, a: 4 }
    const obj = Object.assign(objetoDestino, obj1, obj2)
    
    Object.freeze(obj)
    obj.c = 1234
    console.log(obj)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/890e1d99-c901-40d4-b8b9-a9f0b5bed574/Untitled.png)
    
    Note que o elemento c do objeto obj n√£o foi alterado para 1234, porque congelamos o obj atrav√©s da fun√ß√£o **Object**.freeze( ).
    
- **Heran√ßa:**
    
    Heran√ßa √© um principio da orienta√ß√£o ao objeto, para que se possa utilizar dados de Objetos Pais em outros Objetos Filhos.
    
    - Para acessar atributos de um Objeto como heran√ßa, temos de utilizar o atributo *__proto__*
    - Para acessar atributos de uma fun√ß√£o como heran√ßa, temos de utilizar o atributo **.prototype**
    
    .**prototype**: √â um atributo que s√≥ se encontra dentro de fun√ß√µes e ele √© a ultima est√¢ncia para se acessar como heran√ßa.
    
    Literalmente isso quer dizer que, ao tentar buscar um atributo dentro de um objeto atrav√©s do atributo *__proto__*, se nele n√£o tiver este atributo, ele ir√° buscar no Objeto superior a ele, e assim sussecivamente at√© que se chegue no Objeto a cima de todos os outros.
    
    ```jsx
    // Cadeia de prot√≥tipos (propotype chain)
    Object.prototype.attr0 = '0'
    const avo = { attr1: 'A' }
    const pai = { __proto__: avo, attr2: 'B', attr3: '3' }
    const filho = { __proto__: pai, attr3: 'C' }
    
    console.log(filho.attr0, filho.attr1, filho.attr2, filho.attr3)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cf5c55e5-21e9-491c-8964-9a201a828dba/Untitled.png)
    
    Ent√£o, falando neste assunto, temos an√°lises a serem feitas para as senten√ßas logo a cima.
    
    1. Repare que buscamos no console.log( ), atrav√©s do objeto Filho, atributos que n√£o constam neste objeto, mas que est√£o nos objetos a cima dele, e √© ai que o *__proto__* age, indo buscar aqueles atributos nos objetos a cima at√© chegar no ultimo deles.
    2. Repare tamb√©m, que buscamos atrav√©s do console.log(filho.attr3, o valor do atributo 3 e o retorno foi o valor que esta dentro do objeto filho. Isso porque, o atributo *__proto__* vai buscar os valores sempre respeitando uma hierarquia, trazendo o valor do atributo que ele encontrar primeiro. O que neste caso √© fasil reparar que temos o atributo att3 tanto no objeto filho, quanto no objeto pai, mas como na hierarquia de baixo para cima filho vem primeiro, o resultado na tela √© do valor que consta neste objeto.
    
    **Exemplo1:**
    
    ```jsx
    // Cadeia de prot√≥tipos (propotype chain)
    Object.prototype.attr0 = '0'
    const avo = { attr1: 'A' }
    const pai = { __proto__: avo, attr2: 'B', attr3: '3' }
    const filho = { __proto__: pai, attr3: 'C' }
    
    console.log(filho.attr0, filho.attr1, filho.attr2, filho.attr3)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6a510660-1359-4b8f-bc08-a4ba964b9a01/Untitled.png)
    
                                                                                                                 [üëÜüèæ Voltar a Heran√ßa](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    
    **Exemplo2:**
    
    ```jsx
    const carro = {
      velAtual: 0,
      velMax: 200,
      acelerarMais(delta) {
        if(this.velAtual + delta <= this.velMax) {
          this.velAtual += delta
        } else {
          this.velAtual = this.velMax
        }
      },
      status() {
        return `${this.velAtual}Km/h de ${this.velMax}Km/h.`
      }
    }
    
    const ferrari = {
      modelo: 'F40',
      velMax: 324 // shadowing (Sombreamento)
    }
    const volvo = {
      modelo: 'V40',
      status() {
        return `${this.modelo}: ${super.status()}`
      }
    }
    
    Object.setPrototypeOf(ferrari, carro) // Aqui, estabelecemos uma rela√ß√£o entre o objeto e o seu prototype
    Object.setPrototypeOf(volvo, carro)
    
    console.log(ferrari)
    console.log(volvo)
    
    volvo.acelerarMais(100)
    console.log(volvo.status())
    
    ferrari.acelerarMais(300)
    console.log(ferrari.status())
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7cae8e96-7ed4-4097-8a97-e0b31947de41/Untitled.png)
    
                                                                                                                 [üëÜüèæ Voltar a Heran√ßa](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    
    **Exemplo3:**
    
    Neste segundo exemplo, vamos ver como se relaciona a heran√ßa, quando criamos um Objeto atrav√©s da fun√ß√£o **Object.create( )**. Indentifico que ao criar um obejto ‚Äúprincipal‚Äù como o prot√≥tipo para o objeto filha, o objeto filha herda todas as propriedades do objeto pai. E desta forma, temos acesso em todas as propriedades para alterar elas de qualquer forma. Observe:
    
    ```jsx
    const pai = { nome: 'Pedro', corCabelo: 'Preto'}
    
    const filha1 = Object.create(pai)
    filha1.nome = 'Ana'
    console.log(filha1.corCabelo)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa9a77f8-b58b-4a17-af20-664e6d37a3fd/Untitled.png)
    
    Resultado simples √© de que tivemos acesso a propriedade corCabelo do Objeto Pai, l√° dentro do Objeto filha1.
    
                                                                                                                 [üëÜüèæ Voltar a Heran√ßa](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    
    **Exemplo4:**
    
    Podemos tamb√©m, al√©m de erdar as propriedades atrav√©s do Object.create( ), j√° criar atributos novos para o novo Objeto filha j√° na declara√ß√£o da fun√ß√£o e tamb√©m podemos inclusive configurar como ser√£o feitos os acessos e as configura√ß√µes destes atributos. Veja:
    
    ```jsx
    const filha2 = Object.create(pai, {
      nome: { value: 'Bia', writable: false, enumerable: true }
    })
    
    console.log(filha2.nome)
    filha2.nome = 'Carla'
    console.log(`${filha2.nome} tem cabelo ${filha2.corCabelo}`)
    
    console.log(Object.keys(filha1))
    console.log(Object.keys(filha2))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3beaad05-d418-429f-8aea-0eae352f9202/Untitled.png)
    
    Perceba que na declara√ß√£o do Object.create(filha2) n√≥s configuramos o atributo nome com o writable setado como false. Isso significa que este atributo n√£o pode ter ser valor alterado. E tentamos mudade de Bia para Carla, mas como vimos, esta altera√ß√£o n√£o ocorreu.
    
                                                                                                                 [üëÜüèæ Voltar a Heran√ßa](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    
    **Exemplo5:**
    
    Existe uma forma de verificarmos quais atributos s√£o passados para o Objeto que voc√™ deseja saber, por heran√ßa de outro objeto. Para isso vamos ultizar dentro de uma condi√ß√£o FOR, a fun√ß√£o **.hasOwnProperty( )**
    
    ```jsx
    const pai = { nome: 'Pedro', corCabelo: 'Preto'}
    
    const filha2 = Object.create(pai, {
      nome: { value: 'Bia', writable: false, enumerable: true }
    })
    
    for(let key in filha2) {
      filha2.hasOwnProperty(key) ?
        console.log(key) : console.log(`Por heran√ßa: ${key}`)
    }
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92076040-7bd8-4a89-8f46-2def5dc4e0e3/Untitled.png)
    
    Como identificamos logo a cima, o **FOR** percorreu todas as chaves do Objeto **filha2** e tamb√©m do Objeto **pai**, e identificou que somente a propriedade *corCabelo* venho como heran√ßa do Objeto **pai**. J√° a propriedade *nome*, √© do pr√≥prio Objeto **filha2**.
    
                                                                                                                 [üëÜüèæ Voltar a Heran√ßa](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    
    **Exemplo6.1:**
    
    Neste c√≥digo a seguir vamos identificar que ao estanciar objetos a partir de uma fun√ß√£o construtora, estes objetos ir√£o apontar sempre para o prot√≥tipo **.prototype** daquela fun√ß√£o.
    
    ```jsx
    function MeuObjeto() {}
    console.log(MeuObjeto.prototype)
    
    const obj1 = new MeuObjeto
    const obj2 = new MeuObjeto
    console.log(obj1.__proto__ === obj2.__proto__)
    console.log(MeuObjeto.prototype === obj1.__proto__)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a1a6f50-a087-4ee9-824f-2c4cd4d53667/Untitled.png)
    
    - Como resultado vimos que o __proto__ de todos os objetos que n√≥s estanciar da fun√ß√£o MeuObjeto( ) { }, ser√£o extritamente iguais;
    - E tamb√©m, o prot√≥tipo de todos estes objetos ser√£o extritamente iguais ao prot√≥tipo da fun√ß√£o;
    
    **Exemplo6.2:**
    
    Ainda dentro do mesmo exemplo, vamos ver que pordemo criar outros atributos para a fun√ß√£o MeuObjeto, e assim todos os objetos extanciados a esta fun√ß√£o ir√£o herdar estes atributos.
    
    ```jsx
    function MeuObjeto() {}
    
    const obj1 = new MeuObjeto
    const obj2 = new MeuObjeto
    
    MeuObjeto.prototype.nome = 'An√¥nimo'
    MeuObjeto.prototype.falar = function() {
      console.log(`Bom dia! Meu nome √© ${this.nome}`)
    }
    
    obj1.falar()
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3574634-728c-4ef1-bbcd-6500222e66ae/Untitled.png)
    
    Neste exemplo a cima, n√≥s:
    
    - Criamos o atributo nome e j√° inserimos o valor ‚ÄòAn√¥nimo‚Äô para ele;
    - Criamos como atributo a fun√ß√£o falar que ir√° imprimir em tela uma frase e o valor do atributo nome;
    - E ao acessar o objeto1.falar( ) obtivemos o resultado da fun√ß√£o.
    
                                                                                                                 [üëÜüèæ Voltar a Heran√ßa](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    
    **Exemplo7:**
    
    Podemos tamb√©m mudar o prot√≥tipo de um objeto. Vou mudar o prot√≥tipo __proto__ de um obj3 para MeuObjeto.prototype e desta forma teremos como refer√™ncia m√°xima para o obj3, os atributos da fun√ß√£o MeuObjeto.prototype. Veja:
    
    ```jsx
    function MeuObjeto() {}
    
    MeuObjeto.prototype.nome = 'An√¥nimo'
    MeuObjeto.prototype.falar = function() {
      console.log(`Bom dia! Meu nome √© ${this.nome}`)
    }
    
    const obj3 = {}
    obj3.__proto__ = MeuObjeto.prototype
    obj3.nome = 'Obj3'
    obj3.falar()
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d960fb54-5773-4cb6-ba97-3f3125907725/Untitled.png)
    
    Veja que mesmo n√£o extanciando o **obj3** a fun√ß√£o MeuObjeto, ao apontar o *__proto__* para o **MeuObjeto.prototype**, podemos acessar o atributo (fun√ß√£o) *.falar* da mesma forma.
    
    Resumo:
    
    ```jsx
    // Reusumindo tudo
    console.log((new MeuObjeto).__proto__ === MeuObjeto.prototype)
    console.log(MeuObjeto.__proto__ === Function.prototype)
    console.log(Function.prototype.__proto__ === Object.prototype)
    console.log(Object.prototype.__proto__ === null)
    console.log(Object.prototype.__proto__ === undefined) //Atributo existe mas n√£o aponta para nenhum lugar
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f404af65-b734-4d5c-969d-78fe510d5d83/Untitled.png)
    
                                                                                                                 [üëÜüèæ Voltar a Heran√ßa](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    
    **Exemplo8:**
    
    Uma outra situa√ß√£o importante da heran√ßa, e a de que temos de saber que fun√ß√µes do pr√≥prio sistema tamb√©m possuem um atributo **.prototype.** Isso significa que podemos acrescentar m√©todos a este atributo, mesmo que n√£o sejam m√©todos que tenham j√° pr√© definidos no sistema. Veja que √© verdadeiro elas terem **.prototype**.
    
    ```jsx
    console.log(typeof String)
    console.log(typeof Array)
    console.log(typeof Object)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa83893b-1665-4678-83df-6aae6e9a5f2b/Untitled.png)
    
    **Exemplo8.1:**
    
    Sendo assim, neste exemplo vamos criar um m√©todo reverse para a fun√ß√£o String, de forma que possamos inserir nela uma fun√ß√£o que ir√° quebrar uma determinada frase qualquer (na String) por caracteres atrav√©s do this.split e nele iremos usar o .reverse para colocar estes caracteres de tr√°s para frente e por fim, atrav√©s do .join, iremos juntar novamente este caracter numa nova frase.
    
    Reusmindo, pegamos a frase e escrevemos ela na tela de tr√°s para frente. Observe:
    
    ```jsx
    String.prototype.reverse = function() {
      return this.split('').reverse().join('')
    }
    
    console.log('Escola Cod3r'.reverse())
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3d789769-9532-41b6-b806-ab4bfbf0b50c/Untitled.png)
    
    **Passo a Passo:**
    
    - String.prototype.reverse = function( ) { }:
        - Estamos criando uma fun√ß√£o dentro da fun√ß√£o String para reverter caracteres;
    - this.split(‚Äô  ‚Äò).reverse( ):
        - Esta senten√ßa gera uma array quebrando a frase de dentro da String caracter por caracter, inclusive espa√ß√£o;
            - Exemplo: ‚ÄòEscola Cod3r‚Äô = [ r, 3, d, o, C,   , a, l, o, c, s, E ]
    - **.join**(' '):
        - Esta fun√ß√£o serve para juntar os caracteres novamente em outro Array
            - [ r3doC,   , alocsE ]
    - console.log('Escola Cod3r'.reverse( )):
        - console.log('Escola Cod3r'):
            - √© para imprimir na tela o texto Escola Cod3r
        - .reverse( ):
            - √â a fun√ß√£o que criamos como um atributo dentro da fun√ß√£o String, que ir√° converter o texto de tr√°s para frente.
    
    **Exemplo8.2:**
    
    Podemos tamb√©m criar uma fun√ß√£o (um m√©todo) *.first* por exemplo para uma ***Array***. Vale lembrar que o **Array** n√£o tem este m√©todo na sua extrutura como padr√£o.
    
    Veja:
    
    ```jsx
    Array.prototype.first = function() {
      return this[0]
    }
    console.log([1, 2, 3, 4, 5].first())
    console.log([ 'a', 'b', 'c' ].first())
    ```
    
    ***.frist*** ir√° Retorna o elemento no endere√ßo zero do Array:
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/546dc56e-dbba-4194-99c8-5c2e16cdf5e6/Untitled.png)
    
                                                                                                                 [üëÜüèæ Voltar a Heran√ßa](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)
    
    ## Observa√ß√£o! Podemos inclusive, POR√âM N√ÉO FA√áA, modificar uma fun√ß√£o padr√£o que j√° exista dentro de fun√ß√µes como a String. Cito:
    
    Podemos modificar por exemplo os parametros e comportamentos da fun√ß√£o .toString( ) que vem por padr√£o na metodo String.
    
    ```jsx
    String.prototype.reverse = function() {
      return this.split('').reverse().join('')
    }
    
    String.prototype.toString = function() {
      return 'Ol√° mundo!'
    }
    console.log('Escola Cod3r'.reverse())
    ```
    
    O nomal seria sobre-escrever de tr√°s pra frente a **string *‚ÄòEscola Cod3r‚Äô***, por√©m, como mudamos o m√©todo **.toString** para uma fun√ß√£o com retorno ***‚ÄòOl√° Mundo!‚Äô***, o sistema reverteu o texto ***‚Äò!odnuM √°lO‚Äô***.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e0f87305-99e2-44f9-bd93-890b35e30ed2/Untitled.png)
    
    **Exemplo 9:**
    
    Neste exemplo vamos simular o ‚Äúoperador‚Äù **new** quando utilizamos ele para estanciar um novo objeto. No primeiro bloco de c√≥digos vamos estanciar um objeto de forma leteral (normal) e depois simularemos com uma fun√ß√£o exatamente o que o operador **new** faz no programa.
    
    ```jsx
    function Aula(nome, videoID) {
      this.nome = nome
      this.videoID = videoID
    }
    
    const aula1 = new Aula('Bem Vindo', 123)
    const aula2 = new Aula('At√© Breve', 456)
    console.log(aula1, aula2)
    
    //Simulando o construtor new
    function novo(f, ...params) {
      const obj = {} // Criamos um novo objeto
      obj.__proto__ = f.prototype // "Apontamos" o prototype do new para a nova fun√ß√£o
      f.apply(obj, params)
      return obj
    }
    
    const aula3 = novo(Aula, 'Bem vindo', 123)
    const aula4 = novo(Aula, 'At√© Breve', 456)
    console.log(aula3, aula4)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ed058cb-d50f-4b68-a10b-b2d3bfd75ab7/Untitled.png)
    
- **Evitando Modifica√ß√µes:**
    
    Existem maneiras para evitarmos que sejam feitas modifica√ß√µes nos objetos que criamos em nossa aplica√ß√£o. Seguem alguns exemplos de como fazer isso e qual a diferen√ßa entre as possiveis ferramentas para evitar tais movimentos.
    
    ### ### Object.preventExtensions
    
    Este par√¢metro do Object, serve para previnir que sejam criados novos atributos para o Objeto que n√≥s criamos:
    
    **Exemplo 01:**
    
    ```jsx
    // Object.preventExtensions
    const produto = Object.preventExtensions({
      nome: 'Qualquer', preco: 1.99, tag: 'Promo√ß√£o'
    })
    console.log('Extensivel?', Object.isExtensible(produto))
    
    produto.nome = 'Borracha'
    produto.descricao = 'Borracha escolar Branca'
    delete produto.tag
    console.log(produto)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/94d213bf-7f53-481e-bbac-4454f326275a/Untitled.png)
    
    Neste bloco de c√≥digo logo a cima fizemos alguns testes:
    
    **‚úì Com o c√≥digo Object.isExtensible(produto):**
    
    N√≥s verificamos se o objeto produto √© extensivel para aumentar o n√∫mero de atributos ou n√£o. Resposta false;
    
    **‚úì Com o c√≥digo produto.nome:**
    
    Alteramos o value do atributo nome para ‚ÄòBorracha‚Äô. Altera√ß√£o Ok!;
    
    **‚úì Com o c√≥digo produto.descri√ß√£o = ‚ÄòBorracha escolar Branca‚Äô:**
    
    Tentamos adicionar um novo atributo j√° incluso o value nele ‚ÄòBorracha escolar Branca‚Äô. N√£o conseguimos criar novos atributos, pois o Objeto produto n√£o √© extenssivel a isso;
    
    **‚úì Com o c√≥digo delete produto.tag:**
    
    N√≥s tentamos excluir o atributo tag. Conseguimos excluir atributos;
    
    ### ### Object.seal
    
    **Exemplo2:**
    
    No segundo exemplo, vamos usar o parametro .seal, cujo o qual √© utilizado para ‚Äúselar‚Äù o Objeto de forma a n√£o coneguirmos adicionar ou se quer excluir atributos. Ainda assim, √© possivel alterar os valores dos atributos que j√° existem neste objeto. Veja:
    
    ```jsx
    // Object.seal
    const pessoa = { nome: 'Juliana', idade: 35 }
    Object.seal(pessoa)
    console.log('Selado?:', Object.isSealed(pessoa))
    
    pessoa.sobrenome = 'Silva'
    delete pessoa.nome
    pessoa.idade = 29
    console.log(pessoa)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f23db322-e1aa-435f-b783-9074a6ddebbe/Untitled.png)
    
    **‚úì Com o c√≥digo console.log('Selado?:', Object.isSealed(pessoa)):**
    
    N√≥s verificamos se o objeto esta Selado. Resposta: true;
    
    **‚úì C√≥digo pessoa.sobrenome:**
    
    N√£o √© possivel adicionar e nem alterar valor de um atributo que j√° n√£o exista no objeto;
    
    **‚úì C√≥digo delete pessoa.nome:**
    
    N√£o √© possivel remover um atributo de um objeto selado;
    
    **‚úì C√≥digo pessoa.idade = 29:**
    
    Atrav√©s deste c√≥digo podemos ver que mesmo n√£o podendo modificar os atributos em si, ainda assim podemos modificar o value de cada um dos que j√° existem no Objeto.
    
    ### ### Object.freeze
    
    **Exemplo3:**
    
    Neste ultimo exemplo vamo usar o parametro .freeze que faz o ‚Äúcongelamento‚Äù tanto dos atributos de um objeto, tal como seus valores tamb√©m, n√£o permitindo que haja modifica√ß√µes em nenhum destes dados.
    
    ```jsx
    // Object.freeze = Selado + Valores Constante
    const carro = { marca: 'Fiat', modelo: 'Palio', ano: 2020 }
    Object.freeze(carro)
    console.log('Congelado?:', Object.isFrozen(carro))
    
    carro.marca = 'Ferrari'
    delete carro.ano
    console.log(carro)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ade7e7c9-f376-4c15-8e05-7bf69f55d141/Untitled.png)
    

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# JSON VS OBJETO

Json √© uma ferramenta textual de facil leitura, que serve para criar comunica√ß√£o entre tecnologias diferentes.

Ele tamb√©m serve para guardar configura√ß√µes internas de uma determinada aplica√ß√£o

```jsx
// Transaformando Objeto em JSON
const obj = { a:1, b:2, c:3, soma() { return a + b + c} }
console.log(JSON.stringify(obj))

// Transaformando JSON em Objetos
//console.log(JSON.parse("{ a:1, b:2, c:3 }")) // N√£o √© v√°lido
//console.log(JSON.parse("{ 'a':1, 'b':2, 'c':3 }")) // N√£o √© v√°lido
console.log(JSON.parse('{ "a":1, "b":2, "c":3}'))

// Formatdos v√°lidos dentro de um JSON
console.log(JSON.parse('{ "a":1, "b":"string", "c":true, "d":{}, "e":[], "f":1.99 }'))
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/28d4f3e2-d3fd-4a2c-8ce2-9eedd0d40c4a/Untitled.png)

Nota: Todos os parametros de um JSON sempre ser√£o ‚Äúencapsulados" por aspas duplas (‚Äù ‚Äú);

Nota: Quando houverem atributos que possuem string, elas tamb√©m devem estar ‚Äúencapsulados‚Äù por aspas duplas (‚Äù ‚Äú);

Site de valida√ß√£o de JSON: [https://jsonlint.com/](https://jsonlint.com/)

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# CLASSES

√â uma das alternativas que temos para utilizar componentes em v√°rias partes da aplica√ß√£o.

```jsx
class Lancamento {
  constructor(nome = 'Gen√©rico', valor = 0) {
    this.nome = nome
    this.valor = valor
  }
}

class CicloFinanceiro {
  constructor(mes, ano) {
    this.mes = mes
    this.ano = ano
    this.lancamentos = []
  }

  addLancamentos(...lancamentos) {
    lancamentos.forEach(l => this.lancamentos.push(l))
  }

  sumario() {
    let valorConsolidado = 0
    this.lancamentos.forEach(l => {
      valorConsolidado += l.valor
    })
    return valorConsolidado
  }
}

const salario = new Lancamento('Sal√°rio', 45000)
const contaDeLuz = new Lancamento('Luz', -220)

const contas = new CicloFinanceiro(6, 2018)
contas.addLancamentos(salario, contaDeLuz)
console.log(contas.sumario())
```

Resultado: 44780

## Heran√ßa em Classes

Assim como acontece em Objetos, tamb√©m temos o conceito de heran√ßa nas classes, mudando apenas a sintaxe de como ela √© alcan√ßada.

Para buscar uma dados herdades de uma classe, n√≥s utilizamos comandos como:

- extends ‚áí Este c√≥digo serve para identificar que a classe que esta sendo criada, ser√° uma exten√ß√£o de uma classe j√° existente.
    
     
    
    ```jsx
    class Pai extends Avo {}
    ```
    
- super ‚áí √â um c√≥digo que serve para indicar o atributo que buscaremos l√° da classe principal, para a classe secund√°ria.
    
    ```jsx
    { super(sobrenome) }
    ```
    

Vejamos um exemplo de heran√ßa em classes:

```jsx
class Avo {
  constructor(sobrenome) {
    this.sobrenome = sobrenome
  }
}

class Pai extends Avo {
  constructor(sobrenome, profissao = 'Professor') {
    super(sobrenome)
    this.profissao = profissao
  }
}

class Filho extends Pai {
  constructor() {
    super('Silva')
  }
}

const filho = new Filho
console.log(filho)
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f8d062d3-915d-447d-a3d3-3b6bcc42a3ce/Untitled.png)

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# ARRAY

O array √© uma das ferramentas mais utilizadas no Java Script. Na verdade um array nada mais √© do que uma fun√ß√£o que cria um Objeto, s√≥ que com ferramentas mais robustas que trazem um controle maior dos dados contidos dentro dele.

```jsx
console.log(typeof Array, typeof new Array, typeof [])

let aprovados = new Array('Bia', 'Carlos', 'Ana')
console.log(aprovados)

aprovados = ['Bia', 'Carlos', 'Ana']
console.log(aprovados)
console.log(aprovados[0])
console.log(aprovados[1])
console.log(aprovados[2])
console.log(aprovados[3])

aprovados[3] = 'Paulo'
aprovados.push('Abia') //Insere novo elemento ao array
console.log(aprovados.length) //Traz a quantidade de elementos dentro do array
console.log(aprovados)

aprovados[9] = 'Rafael'
console.log(aprovados.length)
console.log(aprovados)
aprovados.sort() //Organiza os elementos dentro do array
console.log(aprovados)

delete aprovados[1] //Deleta o elemento de dentro do array
console.log(aprovados)

aprovados = ['Bia', 'Carlos', 'Ana']
aprovados.splice(1, 2) //Serve para remover elementos ou dois ao mesmo tempo
console.log(aprovados)

aprovados.splice(1, 2, 'Elemento1', 'Elemento2') //Remove e adiciona elementos
console.log(aprovados)

aprovados.splice(1, 0, 'Elemento3') //Remove e adiciona elementos
console.log(aprovados)
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/48d7b529-f42a-4a4f-b867-9835a0522d79/Untitled.png)

### Fun√ß√µes Importantes do Array

O Array, justamente por ser uma das ferramentas mais importantes de v√°rias aplica√ß√µes, possui metodos (fun√ß√µes) t√£o importantes como ele propriamente dito. Vamos ver algumas.

- .pop( ) ‚áí Esta fun√ß√£o exclui o **√∫ltimo** elemento de dentro de um array.
    
    ```jsx
    const pilotos = ['Vettel', 'Alonso', 'Raikkonem', 'Massa']
    pilotos.pop() // massa quebrou o carro!
    console.log(pilotos)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/58fcf03d-2ad3-4a72-b77c-33ffb63b84e5/Untitled.png)
    

- .shift( ) ‚áí Esta fun√ß√£o exclui o **primeiro** elemento do array.
    
    ```jsx
    const pilotos = ['Vettel', 'Alonso', 'Raikkonem', 'Massa']
    pilotos.shift() //remove o primeiro
    console.log(pilotos)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c983d907-ca3b-4f41-bf0f-415d0a0a3459/Untitled.png)
    

- .push( ) ‚áí Esta fun√ß√£o adiciona um elemento sempre na ultima posi√ß√£o do array.
    
    ```jsx
    const pilotos = ['Vettel', 'Alonso', 'Raikkonem', 'Massa']
    pilotos.push('Verstappen')
    console.log(pilotos)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e9678d69-7179-4ab3-ad2f-16c2eb927c83/Untitled.png)
    

- .unshift( ) ‚áí Esta fun√ß√£o adiciona um elemento na primeira posi√ß√£o do array.
    
    ```jsx
    const pilotos = ['Vettel', 'Alonso', 'Raikkonem', 'Massa']
    pilotos.unshift('Hamilton') //Adiciona elemento na primeira posi√ß√£o do array
    console.log(pilotos)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/829fa408-539a-4f22-abc7-02b1c993bd59/Untitled.png)
    

- .splice( ) ‚áí Esta fun√ß√£o pode tanto remover quanto adicionar elementos a um array. Sendo que √© possivel atrav√©s dela fazer os dois movimentos ao mesmo tempo. E neste fun√ß√£o splice temos:
    
    Adicionando elementos:
    
    - Como primeiro par√¢metro informamos em qual indice ser√° adicionado os novos elementos. Exemplo: 2
    - Segundo par√¢metro. Deixamos o n√∫mero zero(0), identificando assim que nenhum item ser√° removido.
    - A partir do terceiro par√¢metro eu adiciono os itens que eu desejar.
        
        ```jsx
        const pilotos = ['Vettel', 'Alonso', 'Raikkonem', 'Massa']
        // Splice pode adicionar e remover elementos
        console.log(pilotos)
        pilotos.splice(2, 0, 'Bottas', 'Senna')
        console.log(pilotos)
        ```
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3194e576-7554-4966-b80f-2074e382cbf2/Untitled.png)
        
    
    Deletando Elementos:
    
    - No primeiro par√¢metro n√≥s indicamos qual ser√° o indice a ser excluido. Exemplo: 3;
    - No segundo par√¢metro iremos indicar quantos itens ser√£o exlcuidos a partir do indice 3. Exemplo: 1;
    - Como iremos apenas exlcuir itens, n√£o h√° um terceiro par√¢metro;
        
        ```jsx
        const pilotos = ['Vettel', 'Alonso', 'Raikkonem', 'Massa']
        console.log(pilotos)
        pilotos.splice(3, 1) //Massa Quebrou de novo
        console.log(pilotos)
        ```
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b4ecc52-58b0-44ea-a402-9ac88ce58802/Untitled.png)
        

- .slice( ) ‚áí Esta fun√ß√£o serve para criar um novo array contendo pede√ßos do array principal. Ou seja, podemos pegar alguns, ou um √∫nico elemento a partir do indice que indicarmos como par√¢metros da fun√ß√£o.
    
    
    Exemplo 1 - Vamos pegar elementos a partir do indice 2
    
    ```jsx
    const pilotos = ['Vettel', 'Alonso', 'Raikkonem', 'Massa']
    
    const algunsPilotos1 = pilotos.slice(2) //Novo Array
    console.log(pilotos)
    console.log(algunsPilotos1)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5807ffb8-1335-4756-912d-1626c0b53aa7/Untitled.png)
    
    Exemplo 2 - Vamos pegar elementos do incide 1 at√© o indice 3. Detalhe, elemento do √∫ltimo indice indicado, n√£o entra no novo array.
    
    ```jsx
    const pilotos = ['Vettel', 'Alonso', 'Raikkonem', 'Massa']
    
    const algunsPilotos2 = pilotos.slice(1, 3)
    console.log(pilotos)
    console.log(algunsPilotos2)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65837bfa-a3b5-4107-92f2-daf4c8ab346e/Untitled.png)
    

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

### Formas diferentes de percorrer Array

Existem diversas formas de se percorrer um array para obter, excluir, contabilizar ou fazer qualquer outro tipo de modifica√ß√£o a uma array. Vamos ver alguns:

- Foreach( ) ‚áí **Dentro do Foreach tem um la√ßo FOR que serve para percorrer os elementos de um array.**
    
    Um grande detalhe √© que o Foreach sempre retornar dois par√¢metros, sendo eles o primeiro sendo o elemento (nome) e o segundo par√¢metro sentro o √≠ndice. Sendo assim, entende-se que se quisermos obter apenas o nome, n√£o precisa adicionar o segundo par√¢metro, por√©m, se quisermos obter o √≠ndice, ser√° semrpe necess√°rio informar os dois par√¢metros.
    
    **Sendo assim, podemos fazer fun√ß√µes da seguinte forma:**
    
    Exemplo1.
    
    ```jsx
    const aprovados = ['Agatha', 'Aldo', 'Daniel', 'Raquel']
    
    aprovados.forEach(function(nome, indice) {
      console.log(`${indice + 1}) ${nome}`)
    })
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83dbea87-a04b-4766-8269-107c8a0c9fef/Untitled.png)
    
    Com a senten√ßa de c√≥digos a cima, n√≥s utilizamos um foreach( ) para cada elemento percorrido fazemos a aplica√ß√£o chamar uma fun√ß√£o call-back retornando o par√¢metro nome e tamb√©m o par√¢metro indice + 1 (lembrando que o Zero √© o primeiro indice de um array) do Array.
    
    Exemplo2.
    
    ```jsx
    const aprovados = ['Agatha', 'Aldo', 'Daniel', 'Raquel']
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d7d33f68-1cb9-49f6-a59f-6a62be46bcbc/Untitled.png)
    
    Neste segundo exemplo de c√≥digo, apenas percorremos cada elemento, retornando uma aero function imprimindo na tela os elementos do Array.
    
    Exemplo3.
    
    ```jsx
    const aprovados = ['Agatha', 'Aldo', 'Daniel', 'Raquel']
    
    const exibirAprovados = aprovado => console.log(aprovado)
    aprovados.forEach(exibirAprovados)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/367fef08-3642-4209-84e5-479e53e87a30/Untitled.png)
    
    Como podemos ver no c√≥digo a cima, podemos tamb√©m criar uma fun√ß√£o, e usar esta fun√ß√£o como par√¢metro a ser chamado por cada elemento que o foreach( ) chamar.
    
    **EXEMPLO 4 - ATEN√á√ÉO!**
    
    Por padr√£o, o foreach( ) traz um terceiro par√¢metro que √© o pr√≥prio array. Veja:
    
    ```jsx
    const aprovados = ['Agatha', 'Aldo', 'Daniel', 'Raquel']
    
    aprovados.forEach(function(nome, indice, array) {
      console.log(`${indice + 1}) ${nome}`)
      console.log(array)
    })
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/68534bf1-a4e1-4f6e-93df-52557429d675/Untitled.png)
    
    Como podemos ver, foi impresso em tela o terceiro par√¢metro que foi o pr√≥prio array.
    
    ### Criando o nosso foreach( )
    
    ```jsx
    //Criando o pr√≥prio Foreach
    Array.prototype.forEach2 = function(callBack) {
      for (let i = 0; i < this.length; i++) {
        callBack(this[i], i, this)
      }
    }
    
    const aprovados = ['Agatha', 'Aldo', 'Daniel', 'Raquel']
    
    aprovados.forEach2(function(nome, indice) {
      console.log(`${indice + 1}) ${nome}`)
    })
    
    console.log(typeof forEach === typeof forEach2)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/43c640af-8230-4b16-928c-9f88c3f04f6e/Untitled.png)
    

- map( ) ‚áí **Dentro do map tem um la√ßo que serve para transforma√ß√£o no array. Esta fun√ß√£o basicamente mapea o primeiro array e cria um novo elemento de mesmo tamanho com os seus dados transformados.**
    
    **Cabe lembrar que a fun√ß√£o map( ) nunca modifica o array ao qual ele percorreu.**
    
    Exemplo1.
    
    ```jsx
    const nums = [ 1, 2, 3, 4, 5]
    
    // For com prop√≥sito de return
    let resultado = nums.map(function(e) {
      return e * 2
    })
    console.log(resultado)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b27c247-ea13-4990-a4c2-c5e901433b1e/Untitled.png)
    
    A fun√ß√£o map utilizada a cima, percorreu cada um dos elementos, retornando o dobro de cada um deles para dentro de um novo array chamado resultado.
    
    Exemplo2.
    
    ```jsx
    const nums = [ 1, 2, 3, 4, 5]
    
    // For com prop√≥sito de return
    let resultado = nums.map(function(e) {
      return e * 2
    })
    console.log(resultado)
    
    const soma10 = e => e + 10
    const triplo = e => e * 3
    const paraDinheiro = e => `R$${parseFloat(e).toFixed(2).replace('.', ',')}`
    
    resultado = nums.map(soma10).map(triplo).map(paraDinheiro)
    console.log(resultado)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0cc1645f-32e7-481d-b53b-e4216680113b/Untitled.png)
    
    Neste exemplo n√≥s utilizamos o map para cada uma das fun√ß√µes que n√≥s criamos:
    
    1. nums.map(soma10) ‚áí O map percorre cada um dos elementos do array nums, somando a cada um deles mais 10 unidades;
    2. nums.map(soma10).map(triplo) ‚áí Aqui, n√≥s utilizamos o map para pegar o resultado do primeiro map do soma10, e ent√£o n√≥s multiplicamos este resultado por **3** vezes cada elemento;
    3. nums.map(soma10).map(triplo).map(paraDinheiro) ‚áí Por fim, n√≥s pegamos o resultado do map(triplo) * map(soma10) e transformamos ele em uma string dinheiro;
    
    Exemplo2:
    
    ```jsx
    const carrinho = [
      '{ "nome": "Borracha", "preco": 3.45 }',
      '{ "nome": "Caderno", "preco": 13.90 }',
      '{ "nome": "Kit de Lapis", "preco": 41.22 }',
      '{ "nome": "Caneta", "preco": 7.50 }'
    ]
    
    //Retornar um array apenas com os pre√ßos
    const paraObjeto = json => JSON.parse(json)
    const apenasPreco = produto => produto.preco
    
    const resultado = carrinho.map(paraObjeto).map(apenasPreco)
    console.log(resultado)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d240c38b-858c-4739-8893-04cdafa5e04d/Untitled.png)
    
    Utilizamos um array contendo um arquivo Json (string). Por isso antes de mais nada precisamos crair uma fun√ß√£o para converter este Json para um Objeto normal.
    
    Depois, criamos uma outra fun√ß√£o que nos retorna apenas uma ‚Äúparte‚Äù do novo objeto, que √© o pre√ßo.
    
    Por fim, criamos um novo array com o map nos tranzendo tanto o istens quanto seus pre√ßos, e outro array trazendo apenas os pre√ßos.
    
    ### Criando o nosso map( )
    
    ```jsx
    Array.prototype.map2 = function(callBack) {
      const newArray = []
      for (let i = 0; i < this.length; i++ ) {
        newArray.push(callBack(this[i], i, this))
      }
      return newArray
    }
    
    const carrinho = [
      '{ "nome": "Borracha", "preco": 3.45 }',
      '{ "nome": "Caderno", "preco": 13.90 }',
      '{ "nome": "Kit de Lapis", "preco": 41.22 }',
      '{ "nome": "Caneta", "preco": 7.50 }'
    ]
    
    //Retornar um array apenas com os pre√ßos
    const paraObjeto = json => JSON.parse(json)
    const apenasPreco = produto => produto.preco
    
    const resultado = carrinho.map2(paraObjeto).map2(apenasPreco)
    console.log(resultado)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9cfccc00-e5d3-4118-9fea-9b24e43e8468/Untitled.png)
    

- filter( ) ‚áí **A fun√ß√£o filter serve para filtrar os elementos de um array conforme a fun√ß√£o callback que o usu√°rio determinou nesta fun√ß√£o.**
    
    
    Exemplo1.
    
    ```jsx
    const produtos = [
      {nome: 'Noteboock', preco: 2499, fragil: true},
      {nome: 'iPad Pro', preco: 4199, fragil: true},
      {nome: 'Copo de Vidro', preco: 12.49, fragil: true},
      {nome: 'Copo de Pl√°stico', preco: 18.99, fragil: false}
    ]
    
    console.log(produtos.filter(function(p) {
      return false
    }))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b856f33b-fa8b-41e1-a9a2-f8c49ab69a1c/Untitled.png)
    
    Exemplo2
    
    ```jsx
    const produtos = [
      {nome: 'Noteboock', preco: 2499, fragil: true},
      {nome: 'iPad Pro', preco: 4199, fragil: true},
      {nome: 'Copo de Vidro', preco: 12.49, fragil: true},
      {nome: 'Copo de Pl√°stico', preco: 18.99, fragil: false}
    ]
    
    console.log(produtos.filter(function(p) {
      return false
    }))
    
    const caro = produto => produto.preco >= 500
    const fragil = produto => produto.fragil
    
    console.log(produtos.filter(caro).filter(fragil))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d76981bd-9d78-40b9-9853-b9ff640f4728/Untitled.png)
    
    ### Criando o nosso filter( )
    
    ```jsx
    Array.prototype.filter2 = function(callBack) {
      const newArray = []
      for (let i = 0; i < this.length; i++) {
       if(callBack(this[i], i, this)) {
         newArray.push(this[i])
       }
      }
      return newArray
    }
    
    const produtos = [
      {nome: 'Noteboock', preco: 2499, fragil: true},
      {nome: 'iPad Pro', preco: 4199, fragil: true},
      {nome: 'Copo de Vidro', preco: 12.49, fragil: true},
      {nome: 'Copo de Pl√°stico', preco: 18.99, fragil: false}
    ]
    
    console.log(produtos.filter(function(p) {
      return false
    }))
    
    const caro = produto => produto.preco >= 500
    const fragil = produto => produto.fragil
    
    console.log(produtos.filter2(caro).filter2(fragil))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/11a031a4-7dc7-41bf-9048-114f6eac2982/Untitled.png)
    

- reduce( ) ‚áí **√â uma fun√ß√£o que serve para reduzir os elementos de um array para um √∫nico valor, baseando-se em alguma regra pr√©-definida.**
    
    Exemplo01. 
    
    ```jsx
    const alunos = [
      { nome: 'Jo√£o', nota: 7.3, bolsista: false },
      { nome: 'Maria', nota: 9.2, bolsista: true },
      { nome: 'Pedro', nota: 9.8, bolsista: false },
      { nome: 'Ana', nota: 8.7, bolsista: true }
    ]
    console.log(alunos.map(a => a.nota))
    
    const resultado = alunos.map(a => a.nota).reduce(function(acumulador, atual) {
      console.log(acumulador, atual)
      return acumulador + atual
    }, 0)
    
    console.log(resultado)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d154338d-69d2-4895-b7db-25e62b3581e3/Untitled.png)
    
    Neste primeiro exemplo n√≥s utilizamos primeiro uma fun√ß√£o map para trazer somente as notas do array Alunos. Ap√≥s, utilizamos a fun√ß√£o reduce para que a aplica√ß√£o percorrer-se todos os elementos do novo array, somando dentro de uma variavel acumulador, cada nota com o acumulador anterior. Detalhe √© que assim como n√£o tinhamos o parametro de inicio para o acumulador, ele iniciou com zero.
    
    Exemplo2.
    
    ```jsx
    const alunos = [
      { nome: 'Jo√£o', nota: 7.3, bolsista: false },
      { nome: 'Maria', nota: 9.2, bolsista: true },
      { nome: 'Pedro', nota: 9.8, bolsista: false },
      { nome: 'Ana', nota: 8.7, bolsista: true }
    ]
    console.log(alunos.map(a => a.nota))
    
    const resultado = alunos.map(a => a.nota).reduce(function(acumulador, atual) {
      console.log(acumulador, atual)
      return acumulador + atual
    }, 10)
    
    console.log(resultado)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7692fb3c-70e3-4602-a767-2f43511bb129/Untitled.png)
    
    Como neste segundo exemplo iniciamos o acomulador em 10, a conta partiu deste valor.
    
    Exemplo3.
    
    ```jsx
    const alunos = [
      { nome: 'Jo√£o', nota: 7.3, bolsista: false },
      { nome: 'Maria', nota: 9.2, bolsista: true },
      { nome: 'Pedro', nota: 9.8, bolsista: false },
      { nome: 'Ana', nota: 8.7, bolsista: true }
    ]
    
    //Desafio 1: Todos os alunos s√£o bolsistas? use reduce()
    const todosBolsistas = (resultado, bolsista) => resultado && bolsista
    console.log(alunos.map(a => a.bolsista).reduce(todosBolsistas))
    
    //Desafio 2: Algum aluno √© bolsista? use reduce()
    const algumBolsista = (resultado, bolsista) => resultado || bolsista
    console.log(alunos.map(a => a.bolsista).reduce(algumBolsista))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d3e6636-fd46-4314-a09d-269e2e1ef544/Untitled.png)
    
    ### Criando o uma reduce( ) b√°sica:
    
    ```jsx
    //Sem valor inicial
    Array.prototype.reduce2 = function(callBack) {
      let acumulador = this[0]
      for (let i = 1; i < this.length; i++) {
        acumulador = callBack(acumulador, this[i], i, this)
      }
      return acumulador
    }
    
    const soma = (total, valor) => total + valor
    const nums = [ 1, 2, 3, 4, 5, 6]
    console.log(nums.reduce2(soma))
    
    //Com valor inicial
    Array.prototype.reduce2 = function(callBack, valorInicial) {
      const indiceInicial = valorInicial ? 0 : 1
      let acumulador = valorInicial || this[0]
      for (let i = indiceInicial; i < this.length; i++) {
        acumulador = callBack(acumulador, this[i], i, this)
      }
      return acumulador
    }
    
    const soma2 = (total, valor) => total + valor
    const nums2 = [ 1, 2, 3, 4, 5, 6]
    console.log(nums.reduce2(soma2, 21))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa64f582-6dea-4f03-8d1f-6af159e5bdc5/Untitled.png)
    

- reduce( ) ‚áí **√â uma fun√ß√£o que utilizamos para juntar dois ou mais arrays em um novo array, sem alterar os arrays envolvidos.**
    
    Exemplo1.
    
    ```jsx
    const filhas = [ 'Valeskah', 'Cibalena' ]
    const filhos = [ 'Uoxiton', 'Uesclei' ]
    const todos = filhas.concat(filhos)
    
    console.log(filhas)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ea133649-2db2-4ce2-beb5-814acf181414/Untitled.png)
    
    Exemplo2.
    
    ```jsx
    const filhas = [ 'Valeskah', 'Cibalena' ]
    const filhos = [ 'Uoxiton', 'Uesclei' ]
    const todos = filhas.concat(filhos)const todosMaisUm = filhas.concat(filhos, 'Amante')
    console.log(todos)
    console.log(todosMaisUm)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a666c571-f5df-4bb4-a688-d29a5e011ac0/Untitled.png)
    
    Como podemos ver, eu posso concatenar array‚Äôs, j√° incrementando um novo elemento ao mesmo tempo
    
    Exemplo3.
    
    ```jsx
    console.log([].concat([1, 2], [3, 4], 5, [[6,7]]))
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dfcfcc6e-e25a-4917-a8ec-d9294ba1d946/Untitled.png)
    
    Podemos tamb√©m criar um array do zero e j√° concatenar dentro dele elementos, atrav√©s da nota√ß√£o ***ponto(.)***, usando os parametros da fun√ß√£o concat( ) para isso.
    

- flatMap( ) ‚áí **√â uma fun√ß√£o que busca percorrer os elementos dentro de v√°rios arrays, e concatenar em um novo array, tudo ao mesmo tempo, somente os elementos que voc√™ desejar.**
    
    ```jsx
    const escola = [
      {
        nome: 'Turma M1',
        alunos: [
          {
            nome: 'Gustavo',
            nota: 8.1
          },
          {
            nome: 'Ana',
            nota: 9.3
          }
        ]
      },
      {
        nome: 'Turma M2',
        alunos: [
          {
            nome: 'Rebeca',
            nota: 8.9
          },
          {
            nome: 'Roberto',
            nota: 7.3
          }
        ]
      }
    ]
    
    const getNotaDoAluno = aluno => aluno.nota
    const getNotasDaTurma = turma => turma.alunos.map(getNotaDoAluno)
    const notas1 = escola.map(getNotasDaTurma)
    
    console.log(notas1)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3d14d52d-40b7-440e-b9ad-16b645d87456/Untitled.png)
    
    Veja que, sem a fun√ß√£o flatMap( ), n√≥s conseguimos percorrer os elementos do array escola, que s√£o arrays turmas que por sua vez possuem arrays alunos, e trouxemos como resultado um novo array contendo dois elementos. O primeiro elemento √© o array com as notas ta **Turma M1** e o segundo elemento √© um array com as notas da **Turma M2.**
    
    Exemplo2.
    
    Agora vamos criar dentro do protorype do Array (pois ele n√£o tem como padr√£o) a fun√ß√£o flatMap( ):
    
    ```jsx
    const escola = [
      {
        nome: 'Turma M1',
        alunos: [
          {
            nome: 'Gustavo',
            nota: 8.1
          },
          {
            nome: 'Ana',
            nota: 9.3
          }
        ]
      },
      {
        nome: 'Turma M2',
        alunos: [
          {
            nome: 'Rebeca',
            nota: 8.9
          },
          {
            nome: 'Roberto',
            nota: 7.3
          }
        ]
      }
    ]
    
    const getNotaDoAluno = aluno => aluno.nota
    const getNotasDaTurma = turma => turma.alunos.map(getNotaDoAluno)
    
    Array.prototype.flatMap = function(callBack) {
      return Array.prototype.concat.apply([], this.map(callBack))
    }
    
    const notas2 = escola.flatMap(getNotasDaTurma)
    console.log(notas2)
    ```
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/282cdda4-eb6f-4e0e-bff4-0b62a3343e3b/Untitled.png)
    

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)

# IMPERATIVO VS DECLARATIVO

Apenas exemplificando c√≥digos com m√©todos diferentes para as mesmas solu√ß√µes. Neste caso, os dois metodos ir√£o calcular e imprimir em tela a m√©dia de notas do grupo (array) de alunos.

A grander difer√™n√ßa √© que no modo **Imperativo** criamos um c√≥digo que ir√° fazer tudo ao mesmo tempo, sem permitir que parte deste c√≥digo seja utilizado novamente em outro momento da aplica√ß√£o. J√° no modo **Declarativo**, n√≥s conseguimos com menos linhas de c√≥digos, fazer o mesmo processo, utilizando ferramentas que possam ser re-utilizadas em outros momento da nossa aplica√ß√£o.

```jsx
const alunos = [
  { nome: 'Jo√£o', nota: 7.9 },
  { nome: 'Maria', nota: 9.2 },
  { nome: 'Rodrigo', nota: 7.3 },
  { nome: 'Pedro', nota: 5.5 },
]

//Imperativo
let total1 = 0
for (let i = 0; i < alunos.length; i++) {
  total1 += alunos[i].nota
}
console.log(`A m√©dia das notas √©: ${total1 / alunos.length}`)

//Declarativa
const getNota = aluno => aluno.nota
const soma = (total, atual) => total + atual
const total2 = alunos.map(getNota).reduce(soma)
console.log(`A m√©dia das notas √©: ${total1 / alunos.length}`)
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/94bc4d48-a019-40f6-b76e-8ca3e3a33e3b/Untitled.png)

                                                                                                                            [üëÜüèæ Voltar ao Topo](https://www.notion.so/Cod3-Leonardo-15def2e6f305463ca3591313156a0222)